diff --git a/src/main/java/org/apache/commons/io/Charsets.java b/src/main/java/org/apache/commons/io/Charsets.java
index 6ea363e..195c7c6 100644
--- a/src/main/java/org/apache/commons/io/Charsets.java
+++ b/src/main/java/org/apache/commons/io/Charsets.java
@@ -17,7 +17,6 @@
 package org.apache.commons.io;
 
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.Collections;
 import java.util.SortedMap;
 import java.util.TreeMap;
@@ -101,7 +100,7 @@ public class Charsets {
      * @param charset
      *            The name of the requested charset, may be null.
      * @return a Charset for the named charset
-     * @throws UnsupportedCharsetException
+     * @throws java.nio.charset.UnsupportedCharsetException
      *             If the named charset is unavailable
      */
     public static Charset toCharset(final String charset) {
diff --git a/src/main/java/org/apache/commons/io/DirectoryWalker.java b/src/main/java/org/apache/commons/io/DirectoryWalker.java
index 6fdd659..98d1bfb 100644
--- a/src/main/java/org/apache/commons/io/DirectoryWalker.java
+++ b/src/main/java/org/apache/commons/io/DirectoryWalker.java
@@ -390,7 +390,8 @@ public abstract class DirectoryWalker<T> {
      * @param results  the collection of result objects, may be updated
      * @throws IOException if an I/O Error occurs
      */
-    protected final void checkIfCancelled(final File file, final int depth, final Collection<T> results) throws IOException {
+    protected final void checkIfCancelled(final File file, final int depth, final Collection<T> results) throws
+            IOException {
         if (handleIsCancelled(file, depth, results)) {
             throw new CancelException(file, depth);
         }
@@ -485,7 +486,8 @@ public abstract class DirectoryWalker<T> {
      * @return true to process this directory, false to skip this directory
      * @throws IOException if an I/O Error occurs
      */
-    protected boolean handleDirectory(final File directory, final int depth, final Collection<T> results) throws IOException {
+    protected boolean handleDirectory(final File directory, final int depth, final Collection<T> results) throws
+            IOException {
         // do nothing - overridable by subclass
         return true;  // process directory
     }
@@ -500,7 +502,8 @@ public abstract class DirectoryWalker<T> {
      * @param results  the collection of result objects, may be updated
      * @throws IOException if an I/O Error occurs
      */
-    protected void handleDirectoryStart(final File directory, final int depth, final Collection<T> results) throws IOException {
+    protected void handleDirectoryStart(final File directory, final int depth, final Collection<T> results) throws
+            IOException {
         // do nothing - overridable by subclass
     }
 
@@ -516,7 +519,8 @@ public abstract class DirectoryWalker<T> {
      * @throws IOException if an I/O Error occurs
      * @since 2.0
      */
-    protected File[] filterDirectoryContents(final File directory, final int depth, final File[] files) throws IOException {
+    protected File[] filterDirectoryContents(final File directory, final int depth, final File[] files) throws
+            IOException {
         return files;
     }
 
@@ -544,7 +548,8 @@ public abstract class DirectoryWalker<T> {
      * @param results  the collection of result objects, may be updated
      * @throws IOException if an I/O Error occurs
      */
-    protected void handleRestricted(final File directory, final int depth, final Collection<T> results) throws IOException  {
+    protected void handleRestricted(final File directory, final int depth, final Collection<T> results) throws
+            IOException {
         // do nothing - overridable by subclass
     }
 
@@ -558,7 +563,8 @@ public abstract class DirectoryWalker<T> {
      * @param results  the collection of result objects, may be updated
      * @throws IOException if an I/O Error occurs
      */
-    protected void handleDirectoryEnd(final File directory, final int depth, final Collection<T> results) throws IOException {
+    protected void handleDirectoryEnd(final File directory, final int depth, final Collection<T> results) throws
+            IOException {
         // do nothing - overridable by subclass
     }
 
diff --git a/src/main/java/org/apache/commons/io/FileCleaningTracker.java b/src/main/java/org/apache/commons/io/FileCleaningTracker.java
index 839464f..5072711 100644
--- a/src/main/java/org/apache/commons/io/FileCleaningTracker.java
+++ b/src/main/java/org/apache/commons/io/FileCleaningTracker.java
@@ -42,7 +42,7 @@ import java.util.List;
  * @version $Id$
  */
 public class FileCleaningTracker {
-    
+
     // Note: fields are package protected to allow use by test cases
 
     /**
@@ -129,12 +129,13 @@ public class FileCleaningTracker {
 
     /**
      * Adds a tracker to the list of trackers.
-     * 
+     *
      * @param path  the full path to the file to be tracked, not null
      * @param marker  the marker object used to track the file, not null
      * @param deleteStrategy  the strategy to delete the file, null means normal
      */
-    private synchronized void addTracker(final String path, final Object marker, final FileDeleteStrategy deleteStrategy) {
+    private synchronized void addTracker(final String path, final Object marker, final FileDeleteStrategy
+            deleteStrategy) {
         // synchronized block protects reaper
         if (exitWhenFinished) {
             throw new IllegalStateException("No new trackers can be added once exitWhenFinished() is called");
@@ -185,7 +186,7 @@ public class FileCleaningTracker {
      * posing a memory leak.
      * <p>
      * This method allows the thread to be terminated. Simply call this method
-     * in the resource cleanup code, such as 
+     * in the resource cleanup code, such as
      * {@code javax.servlet.ServletContextListener.contextDestroyed(javax.servlet.ServletContextEvent)}.
      * Once called, no new objects can be tracked by the file cleaner.
      */
@@ -257,7 +258,8 @@ public class FileCleaningTracker {
          * @param marker  the marker object used to track the file, not null
          * @param queue  the queue on to which the tracker will be pushed, not null
          */
-        Tracker(final String path, final FileDeleteStrategy deleteStrategy, final Object marker, final ReferenceQueue<? super Object> queue) {
+        Tracker(final String path, final FileDeleteStrategy deleteStrategy, final Object marker,
+                final ReferenceQueue<? super Object> queue) {
             super(marker, queue);
             this.path = path;
             this.deleteStrategy = deleteStrategy == null ? FileDeleteStrategy.NORMAL : deleteStrategy;
diff --git a/src/main/java/org/apache/commons/io/FileSystemUtils.java b/src/main/java/org/apache/commons/io/FileSystemUtils.java
index 903e3dd..ee52f1e 100644
--- a/src/main/java/org/apache/commons/io/FileSystemUtils.java
+++ b/src/main/java/org/apache/commons/io/FileSystemUtils.java
@@ -377,7 +377,8 @@ public class FileSystemUtils {
      * @return the amount of free drive space on the volume
      * @throws IOException if an error occurs
      */
-    long freeSpaceUnix(final String path, final boolean kb, final boolean posix, final long timeout) throws IOException {
+    long freeSpaceUnix(final String path, final boolean kb, final boolean posix, final long timeout)
+            throws IOException {
         if (path.isEmpty()) {
             throw new IllegalArgumentException("Path must not be empty");
         }
diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java
index 2023701..ea27c6b 100644
--- a/src/main/java/org/apache/commons/io/FileUtils.java
+++ b/src/main/java/org/apache/commons/io/FileUtils.java
@@ -27,14 +27,12 @@ import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.Reader;
-import java.io.UnsupportedEncodingException;
 import java.math.BigInteger;
 import java.net.URL;
 import java.net.URLConnection;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
@@ -642,7 +640,8 @@ public class FileUtils {
      * @see org.apache.commons.io.filefilter.NameFileFilter
      * @since 2.2
      */
-    public static Iterator<File> iterateFilesAndDirs(final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {
+    public static Iterator<File> iterateFilesAndDirs(final File directory, final IOFileFilter fileFilter,
+                                                     final IOFileFilter dirFilter) {
         return listFilesAndDirs(directory, fileFilter, dirFilter).iterator();
     }
 
@@ -777,7 +776,8 @@ public class FileUtils {
      * @see IOUtils#contentEqualsIgnoreEOL(Reader, Reader)
      * @since 2.2
      */
-    public static boolean contentEqualsIgnoreEOL(final File file1, final File file2, final String charsetName) throws IOException {
+    public static boolean contentEqualsIgnoreEOL(final File file1, final File file2, final String charsetName)
+            throws IOException {
         final boolean file1Exists = file1.exists();
         if (file1Exists != file2.exists()) {
             return false;
@@ -995,11 +995,13 @@ public class FileUtils {
      * @throws NullPointerException if source or destination is {@code null}
      * @throws IOException          if source or destination is invalid
      * @throws IOException          if an IO error occurs during copying
-     * @throws IOException          if the output file length is not the same as the input file length after the copy completes
+     * @throws IOException          if the output file length is not the same as the input file length after the copy
+     * completes
      * @see #copyFile(File, File, boolean)
      * @since 1.3
      */
-    public static void copyFileToDirectory(final File srcFile, final File destDir, final boolean preserveFileDate) throws IOException {
+    public static void copyFileToDirectory(final File srcFile, final File destDir, final boolean preserveFileDate)
+            throws IOException {
         if (destDir == null) {
             throw new NullPointerException("Destination must not be null");
         }
@@ -1029,7 +1031,8 @@ public class FileUtils {
      * @throws NullPointerException if source or destination is {@code null}
      * @throws IOException          if source or destination is invalid
      * @throws IOException          if an IO error occurs during copying
-     * @throws IOException          if the output file length is not the same as the input file length after the copy completes
+     * @throws IOException          if the output file length is not the same as the input file length after the copy
+     * completes
      * @see #copyFileToDirectory(File, File)
      * @see #copyFile(File, File, boolean)
      */
@@ -1059,7 +1062,8 @@ public class FileUtils {
      * @throws NullPointerException if source or destination is {@code null}
      * @throws IOException          if source or destination is invalid
      * @throws IOException          if an IO error occurs during copying
-     * @throws IOException          if the output file length is not the same as the input file length after the copy completes
+     * @throws IOException          if the output file length is not the same as the input file length after the copy
+     * completes
      * @see #copyFileToDirectory(File, File, boolean)
      * @see #doCopyFile(File, File, boolean)
      */
@@ -1118,10 +1122,13 @@ public class FileUtils {
      * @param destFile         the validated destination file, must not be {@code null}
      * @param preserveFileDate whether to preserve the file date
      * @throws IOException              if an error occurs
-     * @throws IOException              if the output file length is not the same as the input file length after the copy completes
-     * @throws IllegalArgumentException "Negative size" if the file is truncated so that the size is less than the position
+     * @throws IOException              if the output file length is not the same as the input file length after the
+     * copy completes
+     * @throws IllegalArgumentException "Negative size" if the file is truncated so that the size is less than the
+     * position
      */
-    private static void doCopyFile(final File srcFile, final File destFile, final boolean preserveFileDate) throws IOException {
+    private static void doCopyFile(final File srcFile, final File destFile, final boolean preserveFileDate)
+            throws IOException {
         if (destFile.exists() && destFile.isDirectory()) {
             throw new IOException("Destination '" + destFile + "' exists but is a directory");
         }
@@ -1381,15 +1388,21 @@ public class FileUtils {
         doCopyDirectory(srcDir, destDir, filter, preserveFileDate, exclusionList);
     }
 
-    private static void checkFileRequirements(File srcDir, File destDir) throws FileNotFoundException {
-        if (srcDir == null) {
+    /**
+     * checks requirements for file copy
+     * @param src the source file
+     * @param dest the destination
+     * @throws FileNotFoundException if the destination does not exist
+     */
+    private static void checkFileRequirements(File src, File dest) throws FileNotFoundException {
+        if (src == null) {
             throw new NullPointerException("Source must not be null");
         }
-        if (destDir == null) {
+        if (dest == null) {
             throw new NullPointerException("Destination must not be null");
         }
-        if (srcDir.exists() == false) {
-            throw new FileNotFoundException("Source '" + srcDir + "' does not exist");
+        if (!src.exists()) {
+            throw new FileNotFoundException("Source '" + src + "' does not exist");
         }
     }
 
@@ -1405,7 +1418,8 @@ public class FileUtils {
      * @since 1.1
      */
     private static void doCopyDirectory(final File srcDir, final File destDir, final FileFilter filter,
-                                        final boolean preserveFileDate, final List<String> exclusionList) throws IOException {
+                                        final boolean preserveFileDate, final List<String> exclusionList)
+            throws IOException {
         // recurse
         final File[] srcFiles = filter == null ? srcDir.listFiles() : srcDir.listFiles(filter);
         if (srcFiles == null) {  // null if abstract pathname does not denote a directory, or if an I/O error occurs
@@ -1673,6 +1687,12 @@ public class FileUtils {
         }
     }
 
+    /**
+     * Lists files in a directory, asserting that the supplied directory satisfies exists and is a directory
+     * @param directory The directory to list
+     * @return The files in the directory, never null.
+     * @throws IOException if an I/O error occurs
+     */
     private static File[] verifiedListFiles(File directory) throws IOException {
         if (!directory.exists()) {
             final String message = directory + " does not exist";
@@ -1759,8 +1779,8 @@ public class FileUtils {
      * @param encoding the encoding to use, {@code null} means platform default
      * @return the file contents, never {@code null}
      * @throws IOException                 in case of an I/O error
-     * @throws UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *                                     supported.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
      * @since 2.3
      */
     public static String readFileToString(final File file, final String encoding) throws IOException {
@@ -1829,8 +1849,8 @@ public class FileUtils {
      * @param encoding the encoding to use, {@code null} means platform default
      * @return the list of Strings representing each line in the file, never {@code null}
      * @throws IOException                 in case of an I/O error
-     * @throws UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *                                     supported.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
      * @since 1.1
      */
     public static List<String> readLines(final File file, final String encoding) throws IOException {
@@ -1925,7 +1945,8 @@ public class FileUtils {
      * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
      * @since 2.4
      */
-    public static void writeStringToFile(final File file, final String data, final Charset encoding) throws IOException {
+    public static void writeStringToFile(final File file, final String data, final Charset encoding)
+            throws IOException {
         writeStringToFile(file, data, encoding, false);
     }
 
@@ -1956,7 +1977,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 2.3
      */
-    public static void writeStringToFile(final File file, final String data, final Charset encoding, final boolean append) throws IOException {
+    public static void writeStringToFile(final File file, final String data, final Charset encoding, final boolean
+            append) throws IOException {
         OutputStream out = null;
         try {
             out = openOutputStream(file, append);
@@ -1976,11 +1998,12 @@ public class FileUtils {
      * @param append   if {@code true}, then the String will be added to the
      *                 end of the file rather than overwriting
      * @throws IOException                 in case of an I/O error
-     * @throws UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *                                     supported by the VM
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM
      * @since 2.1
      */
-    public static void writeStringToFile(final File file, final String data, final String encoding, final boolean append) throws IOException {
+    public static void writeStringToFile(final File file, final String data, final String encoding,
+                                         final boolean append) throws IOException {
         writeStringToFile(file, data, Charsets.toCharset(encoding), append);
     }
 
@@ -2081,7 +2104,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 2.3
      */
-    public static void write(final File file, final CharSequence data, final Charset encoding, final boolean append) throws IOException {
+    public static void write(final File file, final CharSequence data, final Charset encoding, final boolean append)
+            throws IOException {
         final String str = data == null ? null : data.toString();
         writeStringToFile(file, str, encoding, append);
     }
@@ -2095,11 +2119,12 @@ public class FileUtils {
      * @param append   if {@code true}, then the data will be added to the
      *                 end of the file rather than overwriting
      * @throws IOException                 in case of an I/O error
-     * @throws UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *                                     supported by the VM
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM
      * @since 2.1
      */
-    public static void write(final File file, final CharSequence data, final String encoding, final boolean append) throws IOException {
+    public static void write(final File file, final CharSequence data, final String encoding, final boolean append)
+            throws IOException {
         write(file, data, Charsets.toCharset(encoding), append);
     }
 
@@ -2128,7 +2153,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 2.1
      */
-    public static void writeByteArrayToFile(final File file, final byte[] data, final boolean append) throws IOException {
+    public static void writeByteArrayToFile(final File file, final byte[] data, final boolean append)
+            throws IOException {
         writeByteArrayToFile(file, data, 0, data.length, append);
     }
 
@@ -2144,7 +2170,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 2.5
      */
-    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len) throws IOException {
+    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len)
+            throws IOException {
         writeByteArrayToFile(file, data, off, len, false);
     }
 
@@ -2162,7 +2189,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 2.5
      */
-    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len, final boolean append) throws IOException {
+    public static void writeByteArrayToFile(final File file, final byte[] data, final int off, final int len,
+                                            final boolean append) throws IOException {
         OutputStream out = null;
         try {
             out = openOutputStream(file, append);
@@ -2188,7 +2216,8 @@ public class FileUtils {
      * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
      * @since 1.1
      */
-    public static void writeLines(final File file, final String encoding, final Collection<?> lines) throws IOException {
+    public static void writeLines(final File file, final String encoding, final Collection<?> lines)
+            throws IOException {
         writeLines(file, encoding, lines, null, false);
     }
 
@@ -2206,7 +2235,8 @@ public class FileUtils {
      * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
      * @since 2.1
      */
-    public static void writeLines(final File file, final String encoding, final Collection<?> lines, final boolean append) throws IOException {
+    public static void writeLines(final File file, final String encoding, final Collection<?> lines,
+                                  final boolean append) throws IOException {
         writeLines(file, encoding, lines, null, append);
     }
 
@@ -2256,8 +2286,8 @@ public class FileUtils {
      * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
      * @since 1.1
      */
-    public static void writeLines(final File file, final String encoding, final Collection<?> lines, final String lineEnding)
-            throws IOException {
+    public static void writeLines(final File file, final String encoding, final Collection<?> lines,
+                                  final String lineEnding) throws IOException {
         writeLines(file, encoding, lines, lineEnding, false);
     }
 
@@ -2276,8 +2306,8 @@ public class FileUtils {
      * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
      * @since 2.1
      */
-    public static void writeLines(final File file, final String encoding, final Collection<?> lines, final String lineEnding, final boolean append)
-            throws IOException {
+    public static void writeLines(final File file, final String encoding, final Collection<?> lines,
+                                  final String lineEnding, final boolean append) throws IOException {
         FileOutputStream out = null;
         try {
             out = openOutputStream(file, append);
@@ -2301,7 +2331,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 1.3
      */
-    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding) throws IOException {
+    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding)
+            throws IOException {
         writeLines(file, null, lines, lineEnding, false);
     }
 
@@ -2318,8 +2349,8 @@ public class FileUtils {
      * @throws IOException in case of an I/O error
      * @since 2.1
      */
-    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding, final boolean append)
-            throws IOException {
+    public static void writeLines(final File file, final Collection<?> lines, final String lineEnding,
+                                  final boolean append) throws IOException {
         writeLines(file, null, lines, lineEnding, append);
     }
 
@@ -2553,6 +2584,12 @@ public class FileUtils {
     }
 
     // Private method, must be invoked will a directory parameter
+
+    /**
+     * the size of a director
+     * @param directory the directory to check
+     * @return the size
+     */
     private static long sizeOfDirectory0(final File directory) {
         final File[] files = directory.listFiles();
         if (files == null) {  // null if security restricted
@@ -2577,6 +2614,12 @@ public class FileUtils {
     }
 
     // Internal method - does not check existence
+
+    /**
+     * the size of a file
+     * @param file the file to check
+     * @return the size of the fil
+     */
     private static long sizeOf0(File file) {
         if (file.isDirectory()) {
             return sizeOfDirectory0(file);
@@ -2599,6 +2642,13 @@ public class FileUtils {
     }
 
     // Must be called with a directory
+
+    /**
+     * Finds the size of a directory
+     *
+     * @param directory The directory
+     * @return the size
+     */
     private static BigInteger sizeOfDirectoryBig0(final File directory) {
         final File[] files = directory.listFiles();
         if (files == null) {  // null if security restricted
@@ -2620,6 +2670,12 @@ public class FileUtils {
     }
 
     // internal method; if file does not exist will return 0
+
+    /**
+     * Returns the sid of a file
+     * @param fileOrDir The file
+     * @return the size
+     */
     private static BigInteger sizeOfBig0(final File fileOrDir) {
         if (fileOrDir.isDirectory()) {
             return sizeOfDirectoryBig0(fileOrDir);
@@ -2881,7 +2937,8 @@ public class FileUtils {
      * @throws IOException          if an IO error occurs moving the file
      * @since 1.4
      */
-    public static void moveDirectoryToDirectory(final File src, final File destDir, final boolean createDestDir) throws IOException {
+    public static void moveDirectoryToDirectory(final File src, final File destDir, final boolean createDestDir)
+            throws IOException {
         if (src == null) {
             throw new NullPointerException("Source must not be null");
         }
@@ -2958,7 +3015,8 @@ public class FileUtils {
      * @throws IOException          if an IO error occurs moving the file
      * @since 1.4
      */
-    public static void moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir) throws IOException {
+    public static void moveFileToDirectory(final File srcFile, final File destDir, final boolean createDestDir)
+            throws IOException {
         if (srcFile == null) {
             throw new NullPointerException("Source must not be null");
         }
@@ -2993,7 +3051,8 @@ public class FileUtils {
      * @throws IOException          if an IO error occurs moving the file
      * @since 1.4
      */
-    public static void moveToDirectory(final File src, final File destDir, final boolean createDestDir) throws IOException {
+    public static void moveToDirectory(final File src, final File destDir, final boolean createDestDir)
+            throws IOException {
         if (src == null) {
             throw new NullPointerException("Source must not be null");
         }
diff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java
index 547ba6b..57da01c 100644
--- a/src/main/java/org/apache/commons/io/IOUtils.java
+++ b/src/main/java/org/apache/commons/io/IOUtils.java
@@ -32,7 +32,6 @@ import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.io.Reader;
-import java.io.UnsupportedEncodingException;
 import java.io.Writer;
 import java.net.HttpURLConnection;
 import java.net.ServerSocket;
@@ -44,7 +43,6 @@ import java.nio.ByteBuffer;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.Selector;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -54,7 +52,7 @@ import org.apache.commons.io.output.StringBuilderWriter;
 
 /**
  * General IO stream manipulation utilities.
- * <p>
+ * <p/>
  * This class provides static utility methods for input/output operations.
  * <ul>
  * <li>closeQuietly - these methods close a stream ignoring nulls and exceptions
@@ -63,19 +61,19 @@ import org.apache.commons.io.output.StringBuilderWriter;
  * <li>copy - these methods copy all the data from one stream to another
  * <li>contentEquals - these methods compare the content of two streams
  * </ul>
- * <p>
+ * <p/>
  * The byte-to-char methods and char-to-byte methods involve a conversion step.
  * Two methods are provided in each case, one that uses the platform default
  * encoding and the other which allows you to specify an encoding. You are
  * encouraged to always specify an encoding because relying on the platform
  * default can lead to unexpected results, for example when moving from
  * development to production.
- * <p>
+ * <p/>
  * All the methods in this class that read a stream are buffered internally.
  * This means that there is no cause to use a <code>BufferedInputStream</code>
  * or <code>BufferedReader</code>. The default buffer size of 4K has been shown
  * to be efficient in tests.
- * <p>
+ * <p/>
  * The various copy methods all delegate the actual copying to one of the following methods:
  * <ul>
  * <li>{@link #copyLarge(InputStream, OutputStream, byte[])}</li>
@@ -86,15 +84,15 @@ import org.apache.commons.io.output.StringBuilderWriter;
  * For example, {@link #copy(InputStream, OutputStream)} calls {@link #copyLarge(InputStream, OutputStream)}
  * which calls {@link #copy(InputStream, OutputStream, int)} which creates the buffer and calls
  * {@link #copyLarge(InputStream, OutputStream, byte[])}.
- * <p>
+ * <p/>
  * Applications can re-use buffers by using the underlying methods directly.
  * This may improve performance for applications that need to do a lot of copying.
- * <p>
+ * <p/>
  * Wherever possible, the methods in this class do <em>not</em> flush or close
  * the stream. This is to avoid making non-portable assumptions about the
  * streams' origin and further use. Thus the caller is still responsible for
  * closing streams after use.
- * <p>
+ * <p/>
  * Origin of code: Excalibur.
  *
  * @version $Id$
@@ -193,10 +191,10 @@ public class IOUtils {
 
     /**
      * Closes an <code>Reader</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      *   char[] data = new char[1024];
@@ -212,18 +210,18 @@ public class IOUtils {
      *   }
      * </pre>
      *
-     * @param input  the Reader to close, may be null or already closed
+     * @param input the Reader to close, may be null or already closed
      */
     public static void closeQuietly(final Reader input) {
-        closeQuietly((Closeable)input);
+        closeQuietly((Closeable) input);
     }
 
     /**
      * Closes an <code>Writer</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      *   Writer out = null;
@@ -238,18 +236,18 @@ public class IOUtils {
      *   }
      * </pre>
      *
-     * @param output  the Writer to close, may be null or already closed
+     * @param output the Writer to close, may be null or already closed
      */
     public static void closeQuietly(final Writer output) {
-        closeQuietly((Closeable)output);
+        closeQuietly((Closeable) output);
     }
 
     /**
      * Closes an <code>InputStream</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      *   byte[] data = new byte[1024];
@@ -265,18 +263,18 @@ public class IOUtils {
      *   }
      * </pre>
      *
-     * @param input  the InputStream to close, may be null or already closed
+     * @param input the InputStream to close, may be null or already closed
      */
     public static void closeQuietly(final InputStream input) {
-        closeQuietly((Closeable)input);
+        closeQuietly((Closeable) input);
     }
 
     /**
      * Closes an <code>OutputStream</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      * byte[] data = "Hello, World".getBytes();
@@ -293,20 +291,20 @@ public class IOUtils {
      * }
      * </pre>
      *
-     * @param output  the OutputStream to close, may be null or already closed
+     * @param output the OutputStream to close, may be null or already closed
      */
     public static void closeQuietly(final OutputStream output) {
-        closeQuietly((Closeable)output);
+        closeQuietly((Closeable) output);
     }
 
     /**
      * Closes a <code>Closeable</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in
      * finally blocks.
-     * <p>
+     * <p/>
      * Example code:
-     *
+     * <p/>
      * <pre>
      * Closeable closeable = null;
      * try {
@@ -319,9 +317,9 @@ public class IOUtils {
      *     IOUtils.closeQuietly(closeable);
      * }
      * </pre>
-     *
+     * <p/>
      * Closing all streams:
-     *
+     * <p/>
      * <pre>
      * try {
      *     return IOUtils.copy(inputStream, outputStream);
@@ -331,8 +329,7 @@ public class IOUtils {
      * }
      * </pre>
      *
-     * @param closeable
-     *            the objects to close, may be null or already closed
+     * @param closeable the objects to close, may be null or already closed
      * @since 2.0
      */
     public static void closeQuietly(final Closeable closeable) {
@@ -347,9 +344,9 @@ public class IOUtils {
 
     /**
      * Closes a <code>Closeable</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.
-     * <p>
+     * <p/>
      * This is typically used in finally blocks to ensure that the closeable is closed
      * even if an Exception was thrown before the normal close statement was reached.
      * <br>
@@ -358,9 +355,9 @@ public class IOUtils {
      * <br>
      * It is only intended to simplify tidying up where normal processing has already failed
      * and reporting close failure as well is not necessary or useful.
-     * <p>
+     * <p/>
      * Example code:
-     *
+     * <p/>
      * <pre>
      * Closeable closeable = null;
      * try {
@@ -373,7 +370,7 @@ public class IOUtils {
      *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>
      * }
      * </pre>
-     *
+     * <p/>
      * Closing all streams:
      * <br>
      * <pre>
@@ -384,10 +381,9 @@ public class IOUtils {
      * }
      * </pre>
      *
-     * @param closeables
-     *            the objects to close, may be null or already closed
-     * @since 2.5
+     * @param closeables the objects to close, may be null or already closed
      * @see #closeQuietly(Closeable)
+     * @since 2.5
      */
     public static void closeQuietly(final Closeable... closeables) {
         if (closeables == null) {
@@ -400,10 +396,10 @@ public class IOUtils {
 
     /**
      * Closes a <code>Socket</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link Socket#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      *   Socket socket = null;
@@ -421,8 +417,8 @@ public class IOUtils {
      * @param sock the Socket to close, may be null or already closed
      * @since 2.0
      */
-    public static void closeQuietly(final Socket sock){
-        if (sock != null){
+    public static void closeQuietly(final Socket sock) {
+        if (sock != null) {
             try {
                 sock.close();
             } catch (final IOException ioe) {
@@ -433,10 +429,10 @@ public class IOUtils {
 
     /**
      * Closes a <code>Selector</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link Selector#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      *   Selector selector = null;
@@ -454,10 +450,10 @@ public class IOUtils {
      * @param selector the Selector to close, may be null or already closed
      * @since 2.2
      */
-    public static void closeQuietly(final Selector selector){
-        if (selector != null){
+    public static void closeQuietly(final Selector selector) {
+        if (selector != null) {
             try {
-              selector.close();
+                selector.close();
             } catch (final IOException ioe) {
                 // ignored
             }
@@ -466,10 +462,10 @@ public class IOUtils {
 
     /**
      * Closes a <code>ServerSocket</code> unconditionally.
-     * <p>
+     * <p/>
      * Equivalent to {@link ServerSocket#close()}, except any exceptions will be ignored.
      * This is typically used in finally blocks.
-     * <p>
+     * <p/>
      * Example code:
      * <pre>
      *   ServerSocket socket = null;
@@ -487,8 +483,8 @@ public class IOUtils {
      * @param sock the ServerSocket to close, may be null or already closed
      * @since 2.2
      */
-    public static void closeQuietly(final ServerSocket sock){
-        if (sock != null){
+    public static void closeQuietly(final ServerSocket sock) {
+        if (sock != null) {
             try {
                 sock.close();
             } catch (final IOException ioe) {
@@ -500,7 +496,7 @@ public class IOUtils {
     /**
      * Fetches entire contents of an <code>InputStream</code> and represent
      * same data as result InputStream.
-     * <p>
+     * <p/>
      * This method is useful where,
      * <ul>
      * <li>Source InputStream is slow.</li>
@@ -525,7 +521,7 @@ public class IOUtils {
     /**
      * Fetches entire contents of an <code>InputStream</code> and represent
      * same data as result InputStream.
-     * <p>
+     * <p/>
      * This method is useful where,
      * <ul>
      * <li>Source InputStream is slow.</li>
@@ -552,12 +548,11 @@ public class IOUtils {
      * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given
      * reader.
      *
-     * @param reader
-     *            the reader to wrap or return (not null)
+     * @param reader the reader to wrap or return (not null)
      * @return the given reader or a new {@link BufferedReader} for the given reader
-     * @since 2.2
-     * @see #buffer(Reader)
      * @throws NullPointerException if the input parameter is null
+     * @see #buffer(Reader)
+     * @since 2.2
      */
     public static BufferedReader toBufferedReader(final Reader reader) {
         return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
@@ -567,162 +562,158 @@ public class IOUtils {
      * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given
      * reader.
      *
-     * @param reader
-     *            the reader to wrap or return (not null)
+     * @param reader the reader to wrap or return (not null)
      * @param size the buffer size, if a new BufferedReader is created.
      * @return the given reader or a new {@link BufferedReader} for the given reader
-     * @since 2.5
-     * @see #buffer(Reader)
      * @throws NullPointerException if the input parameter is null
+     * @see #buffer(Reader)
+     * @since 2.5
      */
     public static BufferedReader toBufferedReader(final Reader reader, int size) {
         return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);
     }
 
     /**
-     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the given
-     * reader.
+     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from
+     * the given reader.
      *
-     * @param reader
-     *            the reader to wrap or return (not null)
+     * @param reader the reader to wrap or return (not null)
      * @return the given reader or a new {@link BufferedReader} for the given reader
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedReader buffer(final Reader reader) {
         return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
     }
 
     /**
-     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the given
-     * reader.
+     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the
+     * given reader.
      *
-     * @param reader
-     *            the reader to wrap or return (not null)
+     * @param reader the reader to wrap or return (not null)
      * @param size the buffer size, if a new BufferedReader is created.
      * @return the given reader or a new {@link BufferedReader} for the given reader
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedReader buffer(final Reader reader, int size) {
         return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);
     }
 
     /**
-     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the given
-     * Writer.
+     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the
+     * given Writer.
      *
-     * @param writer
-     *            the Writer to wrap or return (not null)
+     * @param writer the Writer to wrap or return (not null)
      * @return the given Writer or a new {@link BufferedWriter} for the given Writer
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedWriter buffer(final Writer writer) {
         return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);
     }
 
     /**
-     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the given
-     * Writer.
+     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the
+     * given Writer.
      *
-     * @param writer
-     *            the Writer to wrap or return (not null)
+     * @param writer the Writer to wrap or return (not null)
      * @param size the buffer size, if a new BufferedWriter is created.
      * @return the given Writer or a new {@link BufferedWriter} for the given Writer
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedWriter buffer(final Writer writer, int size) {
         return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);
     }
 
     /**
-     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given
-     * OutputStream.
+     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a
+     * BufferedOutputStream from the given OutputStream.
      *
-     * @param outputStream
-     *            the OutputStream to wrap or return (not null)
+     * @param outputStream the OutputStream to wrap or return (not null)
      * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedOutputStream buffer(final OutputStream outputStream) {
         // reject null early on rather than waiting for IO operation to fail
         if (outputStream == null) { // not checked by BufferedOutputStream
             throw new NullPointerException();
         }
-        return outputStream instanceof BufferedOutputStream ? (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);
+        return outputStream instanceof BufferedOutputStream ?
+                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);
     }
 
     /**
-     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a BufferedOutputStream from the given
-     * OutputStream.
+     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a
+     * BufferedOutputStream from the given OutputStream.
      *
-     * @param outputStream
-     *            the OutputStream to wrap or return (not null)
+     * @param outputStream the OutputStream to wrap or return (not null)
      * @param size the buffer size, if a new BufferedOutputStream is created.
      * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedOutputStream buffer(final OutputStream outputStream, int size) {
         // reject null early on rather than waiting for IO operation to fail
         if (outputStream == null) { // not checked by BufferedOutputStream
             throw new NullPointerException();
         }
-        return outputStream instanceof BufferedOutputStream ? (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);
+        return outputStream instanceof BufferedOutputStream ?
+                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);
     }
 
     /**
-     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given
-     * InputStream.
+     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a
+     * BufferedInputStream from the given InputStream.
      *
-     * @param inputStream
-     *            the InputStream to wrap or return (not null)
+     * @param inputStream the InputStream to wrap or return (not null)
      * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedInputStream buffer(final InputStream inputStream) {
         // reject null early on rather than waiting for IO operation to fail
         if (inputStream == null) { // not checked by BufferedInputStream
             throw new NullPointerException();
         }
-        return inputStream instanceof BufferedInputStream ? (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);
+        return inputStream instanceof BufferedInputStream ?
+                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);
     }
 
     /**
-     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given
-     * InputStream.
+     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a
+     * BufferedInputStream from the given InputStream.
      *
-     * @param inputStream
-     *            the InputStream to wrap or return (not null)
+     * @param inputStream the InputStream to wrap or return (not null)
      * @param size the buffer size, if a new BufferedInputStream is created.
      * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream
-     * @since 2.5
      * @throws NullPointerException if the input parameter is null
+     * @since 2.5
      */
     public static BufferedInputStream buffer(final InputStream inputStream, int size) {
         // reject null early on rather than waiting for IO operation to fail
         if (inputStream == null) { // not checked by BufferedInputStream
             throw new NullPointerException();
         }
-        return inputStream instanceof BufferedInputStream ? (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);
+        return inputStream instanceof BufferedInputStream ?
+                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);
     }
 
     // read toByteArray
     //-----------------------------------------------------------------------
+
     /**
      * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param input  the <code>InputStream</code> to read from
+     * @param input the <code>InputStream</code> to read from
      * @return the requested byte array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      */
     public static byte[] toByteArray(final InputStream input) throws IOException {
         final ByteArrayOutputStream output = new ByteArrayOutputStream();
@@ -741,28 +732,31 @@ public class IOUtils {
      * @param input the <code>InputStream</code> to read from
      * @param size the size of <code>InputStream</code>
      * @return the requested byte array
-     * @throws IOException if an I/O error occurs or <code>InputStream</code> size differ from parameter size
+     * @throws IOException              if an I/O error occurs or <code>InputStream</code> size differ from parameter
+     * size
      * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE
      * @see IOUtils#toByteArray(java.io.InputStream, int)
      * @since 2.1
      */
     public static byte[] toByteArray(final InputStream input, final long size) throws IOException {
 
-      if(size > Integer.MAX_VALUE) {
-          throw new IllegalArgumentException("Size cannot be greater than Integer max value: " + size);
-      }
+        if (size > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("Size cannot be greater than Integer max value: " + size);
+        }
 
-      return toByteArray(input, (int) size);
+        return toByteArray(input, (int) size);
     }
 
     /**
      * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.
      * Use this method instead of <code>toByteArray(InputStream)</code>
      * when <code>InputStream</code> size is known
+     *
      * @param input the <code>InputStream</code> to read from
      * @param size the size of <code>InputStream</code>
      * @return the requested byte array
-     * @throws IOException if an I/O error occurs or <code>InputStream</code> size differ from parameter size
+     * @throws IOException              if an I/O error occurs or <code>InputStream</code> size differ from parameter
+     * size
      * @throws IllegalArgumentException if size is less than zero
      * @since 2.1
      */
@@ -794,14 +788,14 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>Reader</code> as a <code>byte[]</code>
      * using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      *
-     * @param input  the <code>Reader</code> to read from
+     * @param input the <code>Reader</code> to read from
      * @return the requested byte array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @deprecated 2.5 use {@link #toByteArray(Reader, Charset)} instead
      */
     @Deprecated
@@ -812,15 +806,15 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>Reader</code> as a <code>byte[]</code>
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>Reader</code> to read from
+     * @param encoding the encoding to use, null means platform default
      * @return the requested byte array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static byte[] toByteArray(final Reader input, final Charset encoding) throws IOException {
@@ -832,21 +826,21 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>Reader</code> as a <code>byte[]</code>
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>Reader</code> to read from
+     * @param encoding the encoding to use, null means platform default
      * @return the requested byte array
-     * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
     public static byte[] toByteArray(final Reader input, final String encoding) throws IOException {
@@ -856,13 +850,13 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>String</code> as a <code>byte[]</code>
      * using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This is the same as {@link String#getBytes()}.
      *
-     * @param input  the <code>String</code> to convert
+     * @param input the <code>String</code> to convert
      * @return the requested byte array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs (never occurs)
+     * @throws IOException          if an I/O error occurs (never occurs)
      * @deprecated 2.5 Use {@link String#getBytes()} instead
      */
     @Deprecated
@@ -874,13 +868,10 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>URI</code> as a <code>byte[]</code>.
      *
-     * @param uri
-     *            the <code>URI</code> to read
+     * @param uri the <code>URI</code> to read
      * @return the requested byte array
-     * @throws NullPointerException
-     *             if the uri is null
-     * @throws IOException
-     *             if an I/O exception occurs
+     * @throws NullPointerException if the uri is null
+     * @throws IOException          if an I/O exception occurs
      * @since 2.4
      */
     public static byte[] toByteArray(final URI uri) throws IOException {
@@ -890,13 +881,10 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>URL</code> as a <code>byte[]</code>.
      *
-     * @param url
-     *            the <code>URL</code> to read
+     * @param url the <code>URL</code> to read
      * @return the requested byte array
-     * @throws NullPointerException
-     *             if the input is null
-     * @throws IOException
-     *             if an I/O exception occurs
+     * @throws NullPointerException if the input is null
+     * @throws IOException          if an I/O exception occurs
      * @since 2.4
      */
     public static byte[] toByteArray(final URL url) throws IOException {
@@ -911,13 +899,10 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>URLConnection</code> as a <code>byte[]</code>.
      *
-     * @param urlConn
-     *            the <code>URLConnection</code> to read
+     * @param urlConn the <code>URLConnection</code> to read
      * @return the requested byte array
-     * @throws NullPointerException
-     *             if the urlConn is null
-     * @throws IOException
-     *             if an I/O exception occurs
+     * @throws NullPointerException if the urlConn is null
+     * @throws IOException          if an I/O exception occurs
      * @since 2.4
      */
     public static byte[] toByteArray(final URLConnection urlConn) throws IOException {
@@ -931,17 +916,18 @@ public class IOUtils {
 
     // read char[]
     //-----------------------------------------------------------------------
+
     /**
      * Gets the contents of an <code>InputStream</code> as a character array
      * using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param is  the <code>InputStream</code> to read from
+     * @param is the <code>InputStream</code> to read from
      * @return the requested character array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #toCharArray(InputStream, Charset)} instead
      */
@@ -953,15 +939,15 @@ public class IOUtils {
     /**
      * Gets the contents of an <code>InputStream</code> as a character array
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param is  the <code>InputStream</code> to read from
-     * @param encoding  the encoding to use, null means platform default
+     * @param is the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
      * @return the requested character array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static char[] toCharArray(final InputStream is, final Charset encoding)
@@ -974,21 +960,21 @@ public class IOUtils {
     /**
      * Gets the contents of an <code>InputStream</code> as a character array
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param is  the <code>InputStream</code> to read from
-     * @param encoding  the encoding to use, null means platform default
+     * @param is the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
      * @return the requested character array
-     * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
     public static char[] toCharArray(final InputStream is, final String encoding) throws IOException {
@@ -997,14 +983,14 @@ public class IOUtils {
 
     /**
      * Gets the contents of a <code>Reader</code> as a character array.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      *
-     * @param input  the <code>Reader</code> to read from
+     * @param input the <code>Reader</code> to read from
      * @return the requested character array
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static char[] toCharArray(final Reader input) throws IOException {
@@ -1015,17 +1001,18 @@ public class IOUtils {
 
     // read toString
     //-----------------------------------------------------------------------
+
     /**
      * Gets the contents of an <code>InputStream</code> as a String
      * using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param input  the <code>InputStream</code> to read from
+     * @param input the <code>InputStream</code> to read from
      * @return the requested String
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @deprecated 2.5 use {@link #toString(InputStream, Charset)} instead
      */
     @Deprecated
@@ -1040,11 +1027,12 @@ public class IOUtils {
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      * </p>
-     * @param input  the <code>InputStream</code> to read from
-     * @param encoding  the encoding to use, null means platform default
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
      * @return the requested String
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static String toString(final InputStream input, final Charset encoding) throws IOException {
@@ -1056,21 +1044,21 @@ public class IOUtils {
     /**
      * Gets the contents of an <code>InputStream</code> as a String
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
      * @return the requested String
-     * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      */
     public static String toString(final InputStream input, final String encoding)
             throws IOException {
@@ -1079,14 +1067,14 @@ public class IOUtils {
 
     /**
      * Gets the contents of a <code>Reader</code> as a String.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      *
-     * @param input  the <code>Reader</code> to read from
+     * @param input the <code>Reader</code> to read from
      * @return the requested String
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      */
     public static String toString(final Reader input) throws IOException {
         final StringBuilderWriter sw = new StringBuilderWriter();
@@ -1097,8 +1085,7 @@ public class IOUtils {
     /**
      * Gets the contents at the given URI.
      *
-     * @param uri
-     *            The URI source.
+     * @param uri The URI source.
      * @return The contents of the URL as a String.
      * @throws IOException if an I/O exception occurs.
      * @since 2.1
@@ -1112,10 +1099,8 @@ public class IOUtils {
     /**
      * Gets the contents at the given URI.
      *
-     * @param uri
-     *            The URI source.
-     * @param encoding
-     *            The encoding name for the URL contents.
+     * @param uri The URI source.
+     * @param encoding The encoding name for the URL contents.
      * @return The contents of the URL as a String.
      * @throws IOException if an I/O exception occurs.
      * @since 2.3.
@@ -1127,15 +1112,13 @@ public class IOUtils {
     /**
      * Gets the contents at the given URI.
      *
-     * @param uri
-     *            The URI source.
-     * @param encoding
-     *            The encoding name for the URL contents.
+     * @param uri The URI source.
+     * @param encoding The encoding name for the URL contents.
      * @return The contents of the URL as a String.
-     * @throws IOException if an I/O exception occurs.
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws IOException                                  if an I/O exception occurs.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 2.1
      */
     public static String toString(final URI uri, final String encoding) throws IOException {
@@ -1145,8 +1128,7 @@ public class IOUtils {
     /**
      * Gets the contents at the given URL.
      *
-     * @param url
-     *            The URL source.
+     * @param url The URL source.
      * @return The contents of the URL as a String.
      * @throws IOException if an I/O exception occurs.
      * @since 2.1
@@ -1160,10 +1142,8 @@ public class IOUtils {
     /**
      * Gets the contents at the given URL.
      *
-     * @param url
-     *            The URL source.
-     * @param encoding
-     *            The encoding name for the URL contents.
+     * @param url The URL source.
+     * @param encoding The encoding name for the URL contents.
      * @return The contents of the URL as a String.
      * @throws IOException if an I/O exception occurs.
      * @since 2.3
@@ -1180,15 +1160,13 @@ public class IOUtils {
     /**
      * Gets the contents at the given URL.
      *
-     * @param url
-     *            The URL source.
-     * @param encoding
-     *            The encoding name for the URL contents.
+     * @param url The URL source.
+     * @param encoding The encoding name for the URL contents.
      * @return The contents of the URL as a String.
-     * @throws IOException if an I/O exception occurs.
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws IOException                                  if an I/O exception occurs.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 2.1
      */
     public static String toString(final URL url, final String encoding) throws IOException {
@@ -1202,7 +1180,7 @@ public class IOUtils {
      * @param input the byte array to read from
      * @return the requested String
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs (never occurs)
+     * @throws IOException          if an I/O error occurs (never occurs)
      * @deprecated 2.5 Use {@link String#String(byte[])} instead
      */
     @Deprecated
@@ -1214,15 +1192,15 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>byte[]</code> as a String
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
      *
      * @param input the byte array to read from
-     * @param encoding  the encoding to use, null means platform default
+     * @param encoding the encoding to use, null means platform default
      * @return the requested String
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs (never occurs)
+     * @throws IOException          if an I/O error occurs (never occurs)
      */
     public static String toString(final byte[] input, final String encoding) throws IOException {
         return new String(input, Charsets.toCharset(encoding));
@@ -1230,17 +1208,18 @@ public class IOUtils {
 
     // readLines
     //-----------------------------------------------------------------------
+
     /**
      * Gets the contents of an <code>InputStream</code> as a list of Strings,
      * one entry per line, using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param input  the <code>InputStream</code> to read from, not null
+     * @param input the <code>InputStream</code> to read from, not null
      * @return the list of Strings, never null
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #readLines(InputStream, Charset)} instead
      */
@@ -1252,15 +1231,15 @@ public class IOUtils {
     /**
      * Gets the contents of an <code>InputStream</code> as a list of Strings,
      * one entry per line, using the specified character encoding.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param input  the <code>InputStream</code> to read from, not null
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
      * @return the list of Strings, never null
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static List<String> readLines(final InputStream input, final Charset encoding) throws IOException {
@@ -1271,21 +1250,21 @@ public class IOUtils {
     /**
      * Gets the contents of an <code>InputStream</code> as a list of Strings,
      * one entry per line, using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      *
-     * @param input  the <code>InputStream</code> to read from, not null
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
      * @return the list of Strings, never null
-     * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
     public static List<String> readLines(final InputStream input, final String encoding) throws IOException {
@@ -1295,14 +1274,14 @@ public class IOUtils {
     /**
      * Gets the contents of a <code>Reader</code> as a list of Strings,
      * one entry per line.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      *
-     * @param input  the <code>Reader</code> to read from, not null
+     * @param input the <code>Reader</code> to read from, not null
      * @return the list of Strings, never null
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static List<String> readLines(final Reader input) throws IOException {
@@ -1318,15 +1297,16 @@ public class IOUtils {
 
     // lineIterator
     //-----------------------------------------------------------------------
+
     /**
      * Returns an Iterator for the lines in a <code>Reader</code>.
-     * <p>
+     * <p/>
      * <code>LineIterator</code> holds a reference to the open
      * <code>Reader</code> specified here. When you have finished with the
      * iterator you should close the reader to free internal resources.
      * This can be done by closing the reader directly, or by calling
      * {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}.
-     * <p>
+     * <p/>
      * The recommended usage pattern is:
      * <pre>
      * try {
@@ -1340,7 +1320,7 @@ public class IOUtils {
      * }
      * </pre>
      *
-     * @param reader  the <code>Reader</code> to read from, not null
+     * @param reader the <code>Reader</code> to read from, not null
      * @return an Iterator of the lines in the reader, never null
      * @throws IllegalArgumentException if the reader is null
      * @since 1.2
@@ -1352,13 +1332,13 @@ public class IOUtils {
     /**
      * Returns an Iterator for the lines in an <code>InputStream</code>, using
      * the character encoding specified (or default encoding if null).
-     * <p>
+     * <p/>
      * <code>LineIterator</code> holds a reference to the open
      * <code>InputStream</code> specified here. When you have finished with
      * the iterator you should close the stream to free internal resources.
      * This can be done by closing the stream directly, or by calling
      * {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}.
-     * <p>
+     * <p/>
      * The recommended usage pattern is:
      * <pre>
      * try {
@@ -1372,11 +1352,11 @@ public class IOUtils {
      * }
      * </pre>
      *
-     * @param input  the <code>InputStream</code> to read from, not null
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
      * @return an Iterator of the lines in the reader, never null
      * @throws IllegalArgumentException if the input is null
-     * @throws IOException if an I/O error occurs, such as if the encoding is invalid
+     * @throws IOException              if an I/O error occurs, such as if the encoding is invalid
      * @since 2.3
      */
     public static LineIterator lineIterator(final InputStream input, final Charset encoding) throws IOException {
@@ -1386,13 +1366,13 @@ public class IOUtils {
     /**
      * Returns an Iterator for the lines in an <code>InputStream</code>, using
      * the character encoding specified (or default encoding if null).
-     * <p>
+     * <p/>
      * <code>LineIterator</code> holds a reference to the open
      * <code>InputStream</code> specified here. When you have finished with
      * the iterator you should close the stream to free internal resources.
      * This can be done by closing the stream directly, or by calling
      * {@link LineIterator#close()} or {@link LineIterator#closeQuietly(LineIterator)}.
-     * <p>
+     * <p/>
      * The recommended usage pattern is:
      * <pre>
      * try {
@@ -1406,14 +1386,14 @@ public class IOUtils {
      * }
      * </pre>
      *
-     * @param input  the <code>InputStream</code> to read from, not null
-     * @param encoding  the encoding to use, null means platform default
+     * @param input the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
      * @return an Iterator of the lines in the reader, never null
-     * @throws IllegalArgumentException if the input is null
-     * @throws IOException if an I/O error occurs, such as if the encoding is invalid
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws IllegalArgumentException                     if the input is null
+     * @throws IOException                                  if an I/O error occurs, such as if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.2
      */
     public static LineIterator lineIterator(final InputStream input, final String encoding) throws IOException {
@@ -1421,6 +1401,7 @@ public class IOUtils {
     }
 
     //-----------------------------------------------------------------------
+
     /**
      * Converts the specified CharSequence to an input stream, encoded as bytes
      * using the default character encoding of the platform.
@@ -1451,17 +1432,17 @@ public class IOUtils {
     /**
      * Converts the specified CharSequence to an input stream, encoded as bytes
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
      *
      * @param input the CharSequence to convert
      * @param encoding the encoding to use, null means platform default
      * @return an input stream
-     * @throws IOException if the encoding is invalid
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws IOException                                  if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 2.0
      */
     public static InputStream toInputStream(final CharSequence input, final String encoding) throws IOException {
@@ -1469,6 +1450,7 @@ public class IOUtils {
     }
 
     //-----------------------------------------------------------------------
+
     /**
      * Converts the specified string to an input stream, encoded as bytes
      * using the default character encoding of the platform.
@@ -1499,17 +1481,17 @@ public class IOUtils {
     /**
      * Converts the specified string to an input stream, encoded as bytes
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
      *
      * @param input the string to convert
      * @param encoding the encoding to use, null means platform default
      * @return an input stream
-     * @throws IOException if the encoding is invalid
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws IOException                                  if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
     public static InputStream toInputStream(final String input, final String encoding) throws IOException {
@@ -1519,14 +1501,15 @@ public class IOUtils {
 
     // write byte[]
     //-----------------------------------------------------------------------
+
     /**
      * Writes bytes from a <code>byte[]</code> to an <code>OutputStream</code>.
      *
-     * @param data  the byte array to write, do not modify during output,
+     * @param data the byte array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>OutputStream</code> to write to
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static void write(final byte[] data, final OutputStream output)
@@ -1541,11 +1524,11 @@ public class IOUtils {
      * This is intended for writing very large byte arrays which might otherwise cause excessive
      * memory usage if the native code has to allocate a copy.
      *
-     * @param data  the byte array to write, do not modify during output,
+     * @param data the byte array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>OutputStream</code> to write to
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.5
      */
     public static void writeChunked(final byte[] data, final OutputStream output)
@@ -1553,7 +1536,7 @@ public class IOUtils {
         if (data != null) {
             int bytes = data.length;
             int offset = 0;
-            while(bytes > 0) {
+            while (bytes > 0) {
                 int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);
                 output.write(data, offset, chunk);
                 bytes -= chunk;
@@ -1565,14 +1548,14 @@ public class IOUtils {
     /**
      * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
      * using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This method uses {@link String#String(byte[])}.
      *
-     * @param data  the byte array to write, do not modify during output,
+     * @param data the byte array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>Writer</code> to write to
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #write(byte[], Writer, Charset)} instead
      */
@@ -1584,15 +1567,15 @@ public class IOUtils {
     /**
      * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * This method uses {@link String#String(byte[], String)}.
      *
-     * @param data  the byte array to write, do not modify during output,
+     * @param data the byte array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>Writer</code> to write to
-     * @param encoding  the encoding to use, null means platform default
+     * @param output the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static void write(final byte[] data, final Writer output, final Charset encoding) throws IOException {
@@ -1604,21 +1587,21 @@ public class IOUtils {
     /**
      * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
      * using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method uses {@link String#String(byte[], String)}.
      *
-     * @param data  the byte array to write, do not modify during output,
+     * @param data the byte array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>Writer</code> to write to
-     * @param encoding  the encoding to use, null means platform default
-     * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param output the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
     public static void write(final byte[] data, final Writer output, final String encoding) throws IOException {
@@ -1627,14 +1610,15 @@ public class IOUtils {
 
     // write char[]
     //-----------------------------------------------------------------------
+
     /**
      * Writes chars from a <code>char[]</code> to a <code>Writer</code>
      *
-     * @param data  the char array to write, do not modify during output,
+     * @param data the char array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>Writer</code> to write to
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static void write(final char[] data, final Writer output) throws IOException {
@@ -1648,18 +1632,18 @@ public class IOUtils {
      * This is intended for writing very large byte arrays which might otherwise cause excessive
      * memory usage if the native code has to allocate a copy.
      *
-     * @param data  the char array to write, do not modify during output,
+     * @param data the char array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>Writer</code> to write to
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.5
      */
     public static void writeChunked(final char[] data, final Writer output) throws IOException {
         if (data != null) {
             int bytes = data.length;
             int offset = 0;
-            while(bytes > 0) {
+            while (bytes > 0) {
                 int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);
                 output.write(data, offset, chunk);
                 bytes -= chunk;
@@ -1671,15 +1655,15 @@ public class IOUtils {
     /**
      * Writes chars from a <code>char[]</code> to bytes on an
      * <code>OutputStream</code>.
-     * <p>
+     * <p/>
      * This method uses {@link String#String(char[])} and
      * {@link String#getBytes()}.
      *
-     * @param data  the char array to write, do not modify during output,
+     * @param data the char array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>OutputStream</code> to write to
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #write(char[], OutputStream, Charset)} instead
      */
@@ -1692,16 +1676,16 @@ public class IOUtils {
     /**
      * Writes chars from a <code>char[]</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * This method uses {@link String#String(char[])} and
      * {@link String#getBytes(String)}.
      *
-     * @param data  the char array to write, do not modify during output,
+     * @param data the char array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static void write(final char[] data, final OutputStream output, final Charset encoding) throws IOException {
@@ -1713,22 +1697,21 @@ public class IOUtils {
     /**
      * Writes chars from a <code>char[]</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method uses {@link String#String(char[])} and
      * {@link String#getBytes(String)}.
      *
-     * @param data  the char array to write, do not modify during output,
+     * @param data the char array to write, do not modify during output,
      * null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
-     * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
      * @since 1.1
      */
     public static void write(final char[] data, final OutputStream output, final String encoding)
@@ -1738,13 +1721,14 @@ public class IOUtils {
 
     // write CharSequence
     //-----------------------------------------------------------------------
+
     /**
      * Writes chars from a <code>CharSequence</code> to a <code>Writer</code>.
      *
-     * @param data  the <code>CharSequence</code> to write, null ignored
-     * @param output  the <code>Writer</code> to write to
+     * @param data the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.0
      */
     public static void write(final CharSequence data, final Writer output) throws IOException {
@@ -1757,13 +1741,13 @@ public class IOUtils {
      * Writes chars from a <code>CharSequence</code> to bytes on an
      * <code>OutputStream</code> using the default character encoding of the
      * platform.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes()}.
      *
-     * @param data  the <code>CharSequence</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
+     * @param data the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.0
      * @deprecated 2.5 use {@link #write(CharSequence, OutputStream, Charset)} instead
      */
@@ -1776,17 +1760,18 @@ public class IOUtils {
     /**
      * Writes chars from a <code>CharSequence</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes(String)}.
      *
-     * @param data  the <code>CharSequence</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
+     * @param data the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
-    public static void write(final CharSequence data, final OutputStream output, final Charset encoding) throws IOException {
+    public static void write(final CharSequence data, final OutputStream output, final Charset encoding)
+            throws IOException {
         if (data != null) {
             write(data.toString(), output, encoding);
         }
@@ -1795,35 +1780,36 @@ public class IOUtils {
     /**
      * Writes chars from a <code>CharSequence</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes(String)}.
      *
-     * @param data  the <code>CharSequence</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
-     * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param data the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException        if output is null
+     * @throws IOException                 if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
      * @since 2.0
      */
-    public static void write(final CharSequence data, final OutputStream output, final String encoding) throws IOException {
+    public static void write(final CharSequence data, final OutputStream output, final String encoding)
+            throws IOException {
         write(data, output, Charsets.toCharset(encoding));
     }
 
     // write String
     //-----------------------------------------------------------------------
+
     /**
      * Writes chars from a <code>String</code> to a <code>Writer</code>.
      *
-     * @param data  the <code>String</code> to write, null ignored
-     * @param output  the <code>Writer</code> to write to
+     * @param data the <code>String</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static void write(final String data, final Writer output) throws IOException {
@@ -1836,13 +1822,13 @@ public class IOUtils {
      * Writes chars from a <code>String</code> to bytes on an
      * <code>OutputStream</code> using the default character encoding of the
      * platform.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes()}.
      *
-     * @param data  the <code>String</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
+     * @param data the <code>String</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #write(String, OutputStream, Charset)} instead
      */
@@ -1855,14 +1841,14 @@ public class IOUtils {
     /**
      * Writes chars from a <code>String</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes(String)}.
      *
-     * @param data  the <code>String</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
+     * @param data the <code>String</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
     public static void write(final String data, final OutputStream output, final Charset encoding) throws IOException {
@@ -1874,20 +1860,19 @@ public class IOUtils {
     /**
      * Writes chars from a <code>String</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes(String)}.
      *
-     * @param data  the <code>String</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
-     * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param data the <code>String</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException        if output is null
+     * @throws IOException                 if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
      * @since 1.1
      */
     public static void write(final String data, final OutputStream output, final String encoding)
@@ -1897,13 +1882,14 @@ public class IOUtils {
 
     // write StringBuffer
     //-----------------------------------------------------------------------
+
     /**
      * Writes chars from a <code>StringBuffer</code> to a <code>Writer</code>.
      *
-     * @param data  the <code>StringBuffer</code> to write, null ignored
-     * @param output  the <code>Writer</code> to write to
+     * @param data the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated replaced by write(CharSequence, Writer)
      */
@@ -1919,13 +1905,13 @@ public class IOUtils {
      * Writes chars from a <code>StringBuffer</code> to bytes on an
      * <code>OutputStream</code> using the default character encoding of the
      * platform.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes()}.
      *
-     * @param data  the <code>StringBuffer</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
+     * @param data the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated replaced by write(CharSequence, OutputStream)
      */
@@ -1938,25 +1924,25 @@ public class IOUtils {
     /**
      * Writes chars from a <code>StringBuffer</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method uses {@link String#getBytes(String)}.
      *
-     * @param data  the <code>StringBuffer</code> to write, null ignored
-     * @param output  the <code>OutputStream</code> to write to
-     * @param encoding  the encoding to use, null means platform default
-     * @throws NullPointerException if output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param data the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException        if output is null
+     * @throws IOException                 if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.
      * @since 1.1
      * @deprecated replaced by write(CharSequence, OutputStream, String)
      */
     @Deprecated
-    public static void write(final StringBuffer data, final OutputStream output, final String encoding) throws IOException {
+    public static void write(final StringBuffer data, final OutputStream output, final String encoding)
+            throws IOException {
         if (data != null) {
             output.write(data.toString().getBytes(Charsets.toCharset(encoding)));
         }
@@ -1964,22 +1950,23 @@ public class IOUtils {
 
     // writeLines
     //-----------------------------------------------------------------------
+
     /**
      * Writes the <code>toString()</code> value of each item in a collection to
      * an <code>OutputStream</code> line by line, using the default character
      * encoding of the platform and the specified line ending.
      *
-     * @param lines  the lines to write, null entries produce blank lines
-     * @param lineEnding  the line separator to use, null is system default
-     * @param output  the <code>OutputStream</code> to write to, not null, not closed
+     * @param lines the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output the <code>OutputStream</code> to write to, not null, not closed
      * @throws NullPointerException if the output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #writeLines(Collection, String, OutputStream, Charset)} instead
      */
     @Deprecated
     public static void writeLines(final Collection<?> lines, final String lineEnding,
-            final OutputStream output) throws IOException {
+                                  final OutputStream output) throws IOException {
         writeLines(lines, lineEnding, output, Charset.defaultCharset());
     }
 
@@ -1988,16 +1975,16 @@ public class IOUtils {
      * an <code>OutputStream</code> line by line, using the specified character
      * encoding and the specified line ending.
      *
-     * @param lines  the lines to write, null entries produce blank lines
-     * @param lineEnding  the line separator to use, null is system default
-     * @param output  the <code>OutputStream</code> to write to, not null, not closed
-     * @param encoding  the encoding to use, null means platform default
+     * @param lines the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output the <code>OutputStream</code> to write to, not null, not closed
+     * @param encoding the encoding to use, null means platform default
      * @throws NullPointerException if the output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
-    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output, final Charset encoding)
-            throws IOException {
+    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output,
+                                  final Charset encoding) throws IOException {
         if (lines == null) {
             return;
         }
@@ -2017,23 +2004,23 @@ public class IOUtils {
      * Writes the <code>toString()</code> value of each item in a collection to
      * an <code>OutputStream</code> line by line, using the specified character
      * encoding and the specified line ending.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
      *
-     * @param lines  the lines to write, null entries produce blank lines
-     * @param lineEnding  the line separator to use, null is system default
-     * @param output  the <code>OutputStream</code> to write to, not null, not closed
-     * @param encoding  the encoding to use, null means platform default
-     * @throws NullPointerException if the output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param lines the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output the <code>OutputStream</code> to write to, not null, not closed
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if the output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
     public static void writeLines(final Collection<?> lines, final String lineEnding,
-            final OutputStream output, final String encoding) throws IOException {
+                                  final OutputStream output, final String encoding) throws IOException {
         writeLines(lines, lineEnding, output, Charsets.toCharset(encoding));
     }
 
@@ -2041,15 +2028,15 @@ public class IOUtils {
      * Writes the <code>toString()</code> value of each item in a collection to
      * a <code>Writer</code> line by line, using the specified line ending.
      *
-     * @param lines  the lines to write, null entries produce blank lines
-     * @param lineEnding  the line separator to use, null is system default
-     * @param writer  the <code>Writer</code> to write to, not null, not closed
+     * @param lines the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param writer the <code>Writer</code> to write to, not null, not closed
      * @throws NullPointerException if the input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static void writeLines(final Collection<?> lines, String lineEnding,
-            final Writer writer) throws IOException {
+                                  final Writer writer) throws IOException {
         if (lines == null) {
             return;
         }
@@ -2066,23 +2053,24 @@ public class IOUtils {
 
     // copy from InputStream
     //-----------------------------------------------------------------------
+
     /**
      * Copies bytes from an <code>InputStream</code> to an
      * <code>OutputStream</code>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * <p>
+     * <p/>
      * Large streams (over 2GB) will return a bytes copied value of
      * <code>-1</code> after the copy has completed since the correct
      * number of bytes cannot be returned as an int. For large streams
      * use the <code>copyLarge(InputStream, OutputStream)</code> method.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
      * @return the number of bytes copied, or -1 if &gt; Integer.MAX_VALUE
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static int copy(final InputStream input, final OutputStream output) throws IOException {
@@ -2096,40 +2084,37 @@ public class IOUtils {
     /**
      * Copies bytes from an <code>InputStream</code> to an <code>OutputStream</code> using an internal buffer of the
      * given size.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a <code>BufferedInputStream</code>.
-     * <p>
-     * @param input
-     *            the <code>InputStream</code> to read from
-     * @param output
-     *            the <code>OutputStream</code> to write to
-     * @param bufferSize
-     *            the bufferSize used to copy from the input to the output
+     * <p/>
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @param bufferSize the bufferSize used to copy from the input to the output
      * @return the number of bytes copied
-     * @throws NullPointerException
-     *             if the input or output is null
-     * @throws IOException
-     *             if an I/O error occurs
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
      * @since 2.5
      */
-    public static long copy(final InputStream input, final OutputStream output, final int bufferSize) throws IOException {
+    public static long copy(final InputStream input, final OutputStream output, final int bufferSize)
+            throws IOException {
         return copyLarge(input, output, new byte[bufferSize]);
     }
 
     /**
      * Copies bytes from a large (over 2GB) <code>InputStream</code> to an
      * <code>OutputStream</code>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * <p>
+     * <p/>
      * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.3
      */
     public static long copyLarge(final InputStream input, final OutputStream output)
@@ -2140,22 +2125,23 @@ public class IOUtils {
     /**
      * Copies bytes from a large (over 2GB) <code>InputStream</code> to an
      * <code>OutputStream</code>.
-     * <p>
+     * <p/>
      * This method uses the provided buffer, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * <p>
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
+     * <p/>
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
      * @param buffer the buffer to use for the copy
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
     public static long copyLarge(final InputStream input, final OutputStream output, final byte[] buffer)
             throws IOException {
         long count = 0;
-        int n = 0;
+        int n;
         while (EOF != (n = input.read(buffer))) {
             output.write(buffer, 0, n);
             count += n;
@@ -2177,18 +2163,18 @@ public class IOUtils {
      * </p>
      * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
      * @param inputOffset : number of bytes to skip from input before copying
-     *         -ve values are ignored
+     * -ve values are ignored
      * @param length : number of bytes to copy. -ve means all
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
-    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset, final long length)
-            throws IOException {
+    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,
+                                 final long length) throws IOException {
         return copyLarge(input, output, inputOffset, length, new byte[DEFAULT_BUFFER_SIZE]);
     }
 
@@ -2205,20 +2191,19 @@ public class IOUtils {
      * this is done to guarantee that the correct number of characters are skipped.
      * </p>
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
      * @param inputOffset : number of bytes to skip from input before copying
-     *         -ve values are ignored
+     * -ve values are ignored
      * @param length : number of bytes to copy. -ve means all
      * @param buffer the buffer to use for the copy
-     *
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
     public static long copyLarge(final InputStream input, final OutputStream output,
-            final long inputOffset, final long length, final byte[] buffer)  throws IOException {
+                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {
         if (inputOffset > 0) {
             skipFully(input, inputOffset);
         }
@@ -2246,16 +2231,16 @@ public class IOUtils {
     /**
      * Copies bytes from an <code>InputStream</code> to chars on a
      * <code>Writer</code> using the default character encoding of the platform.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * <p>
+     * <p/>
      * This method uses {@link InputStreamReader}.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>Writer</code> to write to
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #copy(InputStream, Writer, Charset)} instead
      */
@@ -2268,20 +2253,21 @@ public class IOUtils {
     /**
      * Copies bytes from an <code>InputStream</code> to chars on a
      * <code>Writer</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * <p>
+     * <p/>
      * This method uses {@link InputStreamReader}.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>Writer</code> to write to
-     * @param inputEncoding  the encoding to use for the input stream, null means platform default
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @param inputEncoding the encoding to use for the input stream, null means platform default
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
-    public static void copy(final InputStream input, final Writer output, final Charset inputEncoding) throws IOException {
+    public static void copy(final InputStream input, final Writer output, final Charset inputEncoding)
+            throws IOException {
         final InputStreamReader in = new InputStreamReader(input, Charsets.toCharset(inputEncoding));
         copy(in, output);
     }
@@ -2289,47 +2275,49 @@ public class IOUtils {
     /**
      * Copies bytes from an <code>InputStream</code> to chars on a
      * <code>Writer</code> using the specified character encoding.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * This method uses {@link InputStreamReader}.
      *
-     * @param input  the <code>InputStream</code> to read from
-     * @param output  the <code>Writer</code> to write to
-     * @param inputEncoding  the encoding to use for the InputStream, null means platform default
-     * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @param inputEncoding the encoding to use for the InputStream, null means platform default
+     * @throws NullPointerException                         if the input or output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
-    public static void copy(final InputStream input, final Writer output, final String inputEncoding) throws IOException {
+    public static void copy(final InputStream input, final Writer output, final String inputEncoding)
+            throws IOException {
         copy(input, output, Charsets.toCharset(inputEncoding));
     }
 
     // copy from Reader
     //-----------------------------------------------------------------------
+
     /**
      * Copies chars from a <code>Reader</code> to a <code>Writer</code>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      * Large streams (over 2GB) will return a chars copied value of
      * <code>-1</code> after the copy has completed since the correct
      * number of chars cannot be returned as an int. For large streams
      * use the <code>copyLarge(Reader, Writer)</code> method.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>Writer</code> to write to
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
      * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static int copy(final Reader input, final Writer output) throws IOException {
@@ -2342,17 +2330,17 @@ public class IOUtils {
 
     /**
      * Copies chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>Writer</code> to write to
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
      * @return the number of characters copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.3
      */
     public static long copyLarge(final Reader input, final Writer output) throws IOException {
@@ -2361,22 +2349,22 @@ public class IOUtils {
 
     /**
      * Copies chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
-     * <p>
+     * <p/>
      * This method uses the provided buffer, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>Writer</code> to write to
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
      * @param buffer the buffer to be used for the copy
      * @return the number of characters copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
-    public static long copyLarge(final Reader input, final Writer output, final char [] buffer) throws IOException {
+    public static long copyLarge(final Reader input, final Writer output, final char[] buffer) throws IOException {
         long count = 0;
-        int n = 0;
+        int n;
         while (EOF != (n = input.read(buffer))) {
             output.write(buffer, 0, n);
             count += n;
@@ -2387,47 +2375,48 @@ public class IOUtils {
     /**
      * Copies some or all chars from a large (over 2GB) <code>InputStream</code> to an
      * <code>OutputStream</code>, optionally skipping input chars.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>Writer</code> to write to
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
      * @param inputOffset : number of chars to skip from input before copying
-     *         -ve values are ignored
+     * -ve values are ignored
      * @param length : number of chars to copy. -ve means all
      * @return the number of chars copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
     public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length)
             throws IOException {
-        return  copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]);
+        return copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]);
     }
 
     /**
      * Copies some or all chars from a large (over 2GB) <code>InputStream</code> to an
      * <code>OutputStream</code>, optionally skipping input chars.
-     * <p>
+     * <p/>
      * This method uses the provided buffer, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>Writer</code> to write to
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
      * @param inputOffset : number of chars to skip from input before copying
-     *         -ve values are ignored
+     * -ve values are ignored
      * @param length : number of chars to copy. -ve means all
      * @param buffer the buffer to be used for the copy
      * @return the number of chars copied
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
-    public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length, final char [] buffer)
+    public static long copyLarge(final Reader input, final Writer output, final long inputOffset, final long length,
+                                 final char[] buffer)
             throws IOException {
         if (inputOffset > 0) {
             skipFully(input, inputOffset);
@@ -2456,19 +2445,19 @@ public class IOUtils {
      * Copies chars from a <code>Reader</code> to bytes on an
      * <code>OutputStream</code> using the default character encoding of the
      * platform, and calling flush.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      * Due to the implementation of OutputStreamWriter, this method performs a
      * flush.
-     * <p>
+     * <p/>
      * This method uses {@link OutputStreamWriter}.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>OutputStream</code> to write to
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      * @deprecated 2.5 use {@link #copy(Reader, OutputStream, Charset)} instead
      */
@@ -2494,14 +2483,15 @@ public class IOUtils {
      * This method uses {@link OutputStreamWriter}.
      * </p>
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
-     * @param outputEncoding  the encoding to use for the OutputStream, null means platform default
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @param outputEncoding the encoding to use for the OutputStream, null means platform default
      * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.3
      */
-    public static void copy(final Reader input, final OutputStream output, final Charset outputEncoding) throws IOException {
+    public static void copy(final Reader input, final OutputStream output, final Charset outputEncoding)
+            throws IOException {
         final OutputStreamWriter out = new OutputStreamWriter(output, Charsets.toCharset(outputEncoding));
         copy(input, out);
         // XXX Unless anyone is planning on rewriting OutputStreamWriter,
@@ -2513,47 +2503,49 @@ public class IOUtils {
      * Copies chars from a <code>Reader</code> to bytes on an
      * <code>OutputStream</code> using the specified character encoding, and
      * calling flush.
-     * <p>
+     * <p/>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
-     * <p>
+     * <p/>
      * Character encoding names can be found at
      * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
-     * <p>
+     * <p/>
      * Due to the implementation of OutputStreamWriter, this method performs a
      * flush.
-     * <p>
+     * <p/>
      * This method uses {@link OutputStreamWriter}.
      *
-     * @param input  the <code>Reader</code> to read from
-     * @param output  the <code>OutputStream</code> to write to
-     * @param outputEncoding  the encoding to use for the OutputStream, null means platform default
-     * @throws NullPointerException if the input or output is null
-     * @throws IOException if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @param outputEncoding the encoding to use for the OutputStream, null means platform default
+     * @throws NullPointerException                         if the input or output is null
+     * @throws IOException                                  if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the
+     *                                                      encoding is not supported.
      * @since 1.1
      */
-    public static void copy(final Reader input, final OutputStream output, final String outputEncoding) throws IOException {
+    public static void copy(final Reader input, final OutputStream output, final String outputEncoding)
+            throws IOException {
         copy(input, output, Charsets.toCharset(outputEncoding));
     }
 
     // content equals
     //-----------------------------------------------------------------------
+
     /**
      * Compares the contents of two Streams to determine if they are equal or
      * not.
-     * <p>
+     * <p/>
      * This method buffers the input internally using
      * <code>BufferedInputStream</code> if they are not already buffered.
      *
-     * @param input1  the first stream
-     * @param input2  the second stream
+     * @param input1 the first stream
+     * @param input2 the second stream
      * @return true if the content of the streams are equal or they both don't
      * exist, false otherwise
      * @throws NullPointerException if either input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      */
     public static boolean contentEquals(InputStream input1, InputStream input2)
             throws IOException {
@@ -2583,16 +2575,16 @@ public class IOUtils {
     /**
      * Compares the contents of two Readers to determine if they are equal or
      * not.
-     * <p>
+     * <p/>
      * This method buffers the input internally using
      * <code>BufferedReader</code> if they are not already buffered.
      *
-     * @param input1  the first reader
-     * @param input2  the second reader
+     * @param input1 the first reader
+     * @param input2 the second reader
      * @return true if the content of the readers are equal or they both don't
      * exist, false otherwise
      * @throws NullPointerException if either input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     public static boolean contentEquals(Reader input1, Reader input2)
@@ -2620,15 +2612,15 @@ public class IOUtils {
     /**
      * Compares the contents of two Readers to determine if they are equal or
      * not, ignoring EOL characters.
-     * <p>
+     * <p/>
      * This method buffers the input internally using
      * <code>BufferedReader</code> if they are not already buffered.
      *
-     * @param input1  the first reader
-     * @param input2  the second reader
+     * @param input1 the first reader
+     * @param input2 the second reader
      * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise
      * @throws NullPointerException if either input is null
-     * @throws IOException if an I/O error occurs
+     * @throws IOException          if an I/O error occurs
      * @since 2.2
      */
     public static boolean contentEqualsIgnoreEOL(final Reader input1, final Reader input2)
@@ -2660,16 +2652,13 @@ public class IOUtils {
      * this is done to guarantee that the correct number of bytes are skipped.
      * </p>
      *
-     *
      * @param input byte stream to skip
      * @param toSkip number of bytes to skip.
      * @return number of bytes actually skipped.
-     *
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
      * @see InputStream#skip(long)
      * @see <a href="https://issues.apache.org/jira/browse/IO-203">IO-203 - Add skipFully() method for InputStreams</a>
-     *
-     * @throws IOException if there is a problem reading the file
-     * @throws IllegalArgumentException if toSkip is negative
      * @since 2.0
      */
     public static long skip(final InputStream input, final long toSkip) throws IOException {
@@ -2704,8 +2693,7 @@ public class IOUtils {
      * @param input ReadableByteChannel to skip
      * @param toSkip number of bytes to skip.
      * @return number of bytes actually skipped.
-     *
-     * @throws IOException if there is a problem reading the ReadableByteChannel
+     * @throws IOException              if there is a problem reading the ReadableByteChannel
      * @throws IllegalArgumentException if toSkip is negative
      * @since 2.5
      */
@@ -2742,12 +2730,10 @@ public class IOUtils {
      * @param input character stream to skip
      * @param toSkip number of characters to skip.
      * @return number of characters actually skipped.
-     *
+     * @throws IOException              if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
      * @see Reader#skip(long)
      * @see <a href="https://issues.apache.org/jira/browse/IO-203">IO-203 - Add skipFully() method for InputStreams</a>
-     *
-     * @throws IOException if there is a problem reading the file
-     * @throws IllegalArgumentException if toSkip is negative
      * @since 2.0
      */
     public static long skip(final Reader input, final long toSkip) throws IOException {
@@ -2787,11 +2773,10 @@ public class IOUtils {
      *
      * @param input stream to skip
      * @param toSkip the number of bytes to skip
-     * @see InputStream#skip(long)
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if toSkip is negative
-     * @throws EOFException if the number of bytes skipped was incorrect
+     * @throws EOFException             if the number of bytes skipped was incorrect
+     * @see InputStream#skip(long)
      * @since 2.0
      */
     public static void skipFully(final InputStream input, final long toSkip) throws IOException {
@@ -2809,10 +2794,9 @@ public class IOUtils {
      *
      * @param input ReadableByteChannel to skip
      * @param toSkip the number of bytes to skip
-     *
-     * @throws IOException if there is a problem reading the ReadableByteChannel
+     * @throws IOException              if there is a problem reading the ReadableByteChannel
      * @throws IllegalArgumentException if toSkip is negative
-     * @throws EOFException if the number of bytes skipped was incorrect
+     * @throws EOFException             if the number of bytes skipped was incorrect
      * @since 2.5
      */
     public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {
@@ -2838,11 +2822,10 @@ public class IOUtils {
      *
      * @param input stream to skip
      * @param toSkip the number of characters to skip
-     * @see Reader#skip(long)
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if toSkip is negative
-     * @throws EOFException if the number of characters skipped was incorrect
+     * @throws EOFException             if the number of characters skipped was incorrect
+     * @see Reader#skip(long)
      * @since 2.0
      */
     public static void skipFully(final Reader input, final long toSkip) throws IOException {
@@ -2867,7 +2850,8 @@ public class IOUtils {
      * @throws IOException if a read error occurs
      * @since 2.2
      */
-    public static int read(final Reader input, final char[] buffer, final int offset, final int length) throws IOException {
+    public static int read(final Reader input, final char[] buffer, final int offset, final int length)
+            throws IOException {
         if (length < 0) {
             throw new IllegalArgumentException("Length must not be negative: " + length);
         }
@@ -2913,7 +2897,8 @@ public class IOUtils {
      * @throws IOException if a read error occurs
      * @since 2.2
      */
-    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length) throws IOException {
+    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)
+            throws IOException {
         if (length < 0) {
             throw new IllegalArgumentException("Length must not be negative: " + length);
         }
@@ -2947,7 +2932,7 @@ public class IOUtils {
 
     /**
      * Reads bytes from a ReadableByteChannel.
-     * <p>
+     * <p/>
      * This implementation guarantees that it will read as many bytes
      * as possible before giving up; this may not always be the case for
      * subclasses of {@link ReadableByteChannel}.
@@ -2971,7 +2956,7 @@ public class IOUtils {
 
     /**
      * Reads the requested number of characters or fail if there are not enough left.
-     * <p>
+     * <p/>
      * This allows for the possibility that {@link Reader#read(char[], int, int)} may
      * not read as many characters as requested (most likely because of reaching EOF).
      *
@@ -2979,13 +2964,13 @@ public class IOUtils {
      * @param buffer destination
      * @param offset initial offset into buffer
      * @param length length to read, must be &gt;= 0
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if length is negative
-     * @throws EOFException if the number of characters read was incorrect
+     * @throws EOFException             if the number of characters read was incorrect
      * @since 2.2
      */
-    public static void readFully(final Reader input, final char[] buffer, final int offset, final int length) throws IOException {
+    public static void readFully(final Reader input, final char[] buffer, final int offset, final int length)
+            throws IOException {
         final int actual = read(input, buffer, offset, length);
         if (actual != length) {
             throw new EOFException("Length to read: " + length + " actual: " + actual);
@@ -2994,16 +2979,15 @@ public class IOUtils {
 
     /**
      * Reads the requested number of characters or fail if there are not enough left.
-     * <p>
+     * <p/>
      * This allows for the possibility that {@link Reader#read(char[], int, int)} may
      * not read as many characters as requested (most likely because of reaching EOF).
      *
      * @param input where to read input from
      * @param buffer destination
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if length is negative
-     * @throws EOFException if the number of characters read was incorrect
+     * @throws EOFException             if the number of characters read was incorrect
      * @since 2.2
      */
     public static void readFully(final Reader input, final char[] buffer) throws IOException {
@@ -3012,7 +2996,7 @@ public class IOUtils {
 
     /**
      * Reads the requested number of bytes or fail if there are not enough left.
-     * <p>
+     * <p/>
      * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
      * not read as many bytes as requested (most likely because of reaching EOF).
      *
@@ -3020,13 +3004,13 @@ public class IOUtils {
      * @param buffer destination
      * @param offset initial offset into buffer
      * @param length length to read, must be &gt;= 0
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if length is negative
-     * @throws EOFException if the number of bytes read was incorrect
+     * @throws EOFException             if the number of bytes read was incorrect
      * @since 2.2
      */
-    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length) throws IOException {
+    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)
+            throws IOException {
         final int actual = read(input, buffer, offset, length);
         if (actual != length) {
             throw new EOFException("Length to read: " + length + " actual: " + actual);
@@ -3035,16 +3019,15 @@ public class IOUtils {
 
     /**
      * Reads the requested number of bytes or fail if there are not enough left.
-     * <p>
+     * <p/>
      * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
      * not read as many bytes as requested (most likely because of reaching EOF).
      *
      * @param input where to read input from
      * @param buffer destination
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if length is negative
-     * @throws EOFException if the number of bytes read was incorrect
+     * @throws EOFException             if the number of bytes read was incorrect
      * @since 2.2
      */
     public static void readFully(final InputStream input, final byte[] buffer) throws IOException {
@@ -3053,19 +3036,16 @@ public class IOUtils {
 
     /**
      * Reads the requested number of bytes or fail if there are not enough left.
-     * <p>
+     * <p/>
      * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
      * not read as many bytes as requested (most likely because of reaching EOF).
      *
      * @param input where to read input from
      * @param length length to read, must be &gt;= 0
-     *
      * @return the bytes read from input
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException              if there is a problem reading the file
      * @throws IllegalArgumentException if length is negative
-     * @throws EOFException if the number of bytes read was incorrect
-     *
+     * @throws EOFException             if the number of bytes read was incorrect
      * @since 2.5
      */
     public static byte[] readFully(final InputStream input, final int length) throws IOException {
@@ -3076,14 +3056,13 @@ public class IOUtils {
 
     /**
      * Reads the requested number of bytes or fail if there are not enough left.
-     * <p>
+     * <p/>
      * This allows for the possibility that {@link ReadableByteChannel#read(ByteBuffer)} may
      * not read as many bytes as requested (most likely because of reaching EOF).
      *
      * @param input the byte channel to read
      * @param buffer byte buffer destination
-     *
-     * @throws IOException if there is a problem reading the file
+     * @throws IOException  if there is a problem reading the file
      * @throws EOFException if the number of bytes read was incorrect
      * @since 2.5
      */
diff --git a/src/main/java/org/apache/commons/io/Java7Support.java b/src/main/java/org/apache/commons/io/Java7Support.java
index 50078f3..d9033a4 100644
--- a/src/main/java/org/apache/commons/io/Java7Support.java
+++ b/src/main/java/org/apache/commons/io/Java7Support.java
@@ -78,6 +78,11 @@ class Java7Support {
         IS_JAVA7 = isJava7x;
     }
 
+    /**
+     * Invokes java7 isSymbolicLink
+     * @param file The file to check
+     * @return true if the file is a symbolic link
+     */
     public static boolean isSymLink(File file) {
         try {
             Object path = toPath.invoke(file);
@@ -90,6 +95,12 @@ class Java7Support {
         }
     }
 
+    /**
+     * Reads the target of a symbolic link
+     * @param symlink The symlink to read
+     * @return The location the symlink is pointing to
+     * @throws IOException Upon failure
+     */
 
     public static File readSymbolicLink(File symlink)
             throws IOException {
@@ -105,7 +116,13 @@ class Java7Support {
     }
 
 
-    public static boolean exists(File file)
+    /**
+     * Indicates if a symlunk target exists
+     * @param file The symlink file
+     * @return true if the target exists
+     * @throws IOException upon error
+     */
+    private static boolean exists(File file)
             throws IOException {
         try {
             Object path = toPath.invoke(file);
@@ -119,6 +136,13 @@ class Java7Support {
 
     }
 
+    /**
+     * Creates a symbolic link
+     * @param symlink The symlink to create
+     * @param target Where it should point
+     * @return The newly created symlink
+     * @throws IOException upon error
+     */
     public static File createSymbolicLink(File symlink, File target)
             throws IOException {
         try {
@@ -141,7 +165,7 @@ class Java7Support {
      * Performs a nio delete
      *
      * @param file the file to delete
-     * @throws IOException
+     * @throws IOException Upon error
      */
     public static void delete(File file)
             throws IOException {
@@ -155,6 +179,10 @@ class Java7Support {
         }
     }
 
+    /**
+     * Indicates if the current vm has java7 lubrary support
+     * @return true if java7 library support
+     */
     public static boolean isAtLeastJava7() {
         return IS_JAVA7;
     }
diff --git a/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
index e9d13ef..00aa996 100644
--- a/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
@@ -170,7 +170,8 @@ public class MagicNumberFileFilter extends AbstractFileFilter implements
             throw new IllegalArgumentException("The offset cannot be negative");
         }
 
-        this.magicNumbers = magicNumber.getBytes(Charset.defaultCharset()); // explicitly uses the platform default charset
+        this.magicNumbers = magicNumber.getBytes(Charset.defaultCharset()); // explicitly uses the platform default
+                                                                            // charset
         this.byteOffset = offset;
     }
 
@@ -263,7 +264,8 @@ public class MagicNumberFileFilter extends AbstractFileFilter implements
     public String toString() {
         final StringBuilder builder = new StringBuilder(super.toString());
         builder.append("(");
-        builder.append(new String(magicNumbers, Charset.defaultCharset()));// TODO perhaps use hex if value is not printable
+        builder.append(new String(magicNumbers, Charset.defaultCharset()));// TODO perhaps use hex if value is not
+                                                                           // printable
         builder.append(",");
         builder.append(this.byteOffset);
         builder.append(")");
diff --git a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
index fd80ff9..ab75471 100644
--- a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
@@ -66,7 +66,8 @@ public class CharSequenceInputStream extends InputStream {
         // Ensure that buffer is long enough to hold a complete character
         final float maxBytesPerChar = encoder.maxBytesPerChar();
         if (bufferSize < maxBytesPerChar) {
-            throw new IllegalArgumentException("Buffer size " + bufferSize + " is less than maxBytesPerChar " + maxBytesPerChar);
+            throw new IllegalArgumentException("Buffer size " + bufferSize + " is less than maxBytesPerChar " +
+                    maxBytesPerChar);
         }
         this.bbuf = ByteBuffer.allocate(bufferSize);
         this.bbuf.flip();
@@ -233,9 +234,10 @@ public class CharSequenceInputStream extends InputStream {
          * Since the bbuf is re-used, in general it's necessary to re-encode the data.
          *
          * It should be possible to apply some optimisations however:
-         * + use mark/reset on the cbuf and bbuf. This would only work if the buffer had not been (re)filled since the mark.
-         * The code would have to catch InvalidMarkException - does not seem possible to check if mark is valid otherwise.
-         * + Try saving the state of the cbuf before each fillBuffer; it might be possible to restart from there.
+         * + use mark/reset on the cbuf and bbuf. This would only work if the buffer had not been (re)filled since
+         * the mark. The code would have to catch InvalidMarkException - does not seem possible to check if mark is
+         * valid otherwise. + Try saving the state of the cbuf before each fillBuffer; it might be possible to
+         * restart from there.
          */
         if (this.mark_cbuf != NO_MARK) {
             // if cbuf is at 0, we have not started reading anything, so skip re-encoding
@@ -251,7 +253,8 @@ public class CharSequenceInputStream extends InputStream {
                 }
             }
             if (this.cbuf.position() != this.mark_cbuf) {
-                throw new IllegalStateException("Unexpected CharBuffer postion: actual="+cbuf.position() + " expected=" + this.mark_cbuf);
+                throw new IllegalStateException("Unexpected CharBuffer postion: actual=" + cbuf.position() + " " +
+                        "expected=" + this.mark_cbuf);
             }
             this.bbuf.position(this.mark_bbuf);
             this.mark_cbuf = NO_MARK;
diff --git a/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java b/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java
index 9518c4a..e12a47d 100644
--- a/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java
+++ b/src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java
@@ -23,7 +23,6 @@ import java.io.RandomAccessFile;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
-import java.nio.charset.UnsupportedCharsetException;
 
 import org.apache.commons.io.Charsets;
 
@@ -121,7 +120,8 @@ public class ReversedLinesFileReader implements Closeable {
             // UTF-8 works fine out of the box, for multibyte sequences a second UTF-8 byte can never be a newline byte
             // http://en.wikipedia.org/wiki/UTF-8
             byteDecrement = 1;
-        } else if(charset == Charset.forName("Shift_JIS") || // Same as for UTF-8 http://www.herongyang.com/Unicode/JIS-Shift-JIS-Encoding.html
+        } else if(charset == Charset.forName("Shift_JIS") || // Same as for UTF-8
+                                      // http://www.herongyang.com/Unicode/JIS-Shift-JIS-Encoding.html
                 charset == Charset.forName("windows-31j") || // Windows code page 932 (Japanese)
                 charset == Charset.forName("x-windows-949") || // Windows code page 949 (Korean)
                 charset == Charset.forName("gbk") || // Windows code page 936 (Simplified Chinese)
@@ -132,9 +132,11 @@ public class ReversedLinesFileReader implements Closeable {
             // however byte order has to be specified
             byteDecrement = 2;
         } else if (charset == Charsets.UTF_16) {
-            throw new UnsupportedEncodingException("For UTF-16, you need to specify the byte order (use UTF-16BE or UTF-16LE)");
+            throw new UnsupportedEncodingException("For UTF-16, you need to specify the byte order (use UTF-16BE or " +
+                    "UTF-16LE)");
         } else {
-            throw new UnsupportedEncodingException("Encoding " + encoding + " is not supported yet (feel free to submit a patch)");
+            throw new UnsupportedEncodingException("Encoding " + encoding + " is not supported yet (feel free to " +
+                    "submit a patch)");
         }
         // NOTE: The new line sequences are matched in the order given, so it is important that \r\n is BEFORE \n
         newLineSequences = new byte[][] { "\r\n".getBytes(encoding), "\n".getBytes(encoding), "\r".getBytes(encoding) };
@@ -153,9 +155,8 @@ public class ReversedLinesFileReader implements Closeable {
      * @param encoding
      *            the encoding of the file
      * @throws IOException  if an I/O error occurs
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
-     *             supported.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in
+     * version 2.2 if the encoding is not supported.
      */
     public ReversedLinesFileReader(final File file, final int blockSize, final String encoding) throws IOException {
         this(file, blockSize, Charsets.toCharset(encoding));
diff --git a/src/main/java/org/apache/commons/io/input/Tailer.java b/src/main/java/org/apache/commons/io/input/Tailer.java
index 9ed4db0..ade7cd8 100644
--- a/src/main/java/org/apache/commons/io/input/Tailer.java
+++ b/src/main/java/org/apache/commons/io/input/Tailer.java
@@ -207,7 +207,8 @@ public class Tailer implements Runnable {
      * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
      * @param reOpen if true, close and reopen the file between reading chunks
      */
-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {
+    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end,
+                  final boolean reOpen) {
         this(file, listener, delayMillis, end, reOpen, DEFAULT_BUFSIZE);
     }
 
@@ -219,7 +220,8 @@ public class Tailer implements Runnable {
      * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
      * @param bufSize Buffer size
      */
-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufSize) {
+    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end,
+                  final int bufSize) {
         this(file, listener, delayMillis, end, false, bufSize);
     }
 
@@ -232,7 +234,8 @@ public class Tailer implements Runnable {
      * @param reOpen if true, close and reopen the file between reading chunks
      * @param bufSize Buffer size
      */
-    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufSize) {
+    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end,
+                  final boolean reOpen, final int bufSize) {
         this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufSize);
     }
 
@@ -246,7 +249,8 @@ public class Tailer implements Runnable {
      * @param reOpen if true, close and reopen the file between reading chunks
      * @param bufSize Buffer size
      */
-    public Tailer(final File file, final Charset cset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen
+    public Tailer(final File file, final Charset cset, final TailerListener listener, final long delayMillis,
+                  final boolean end, final boolean reOpen
             , final int bufSize) {
         this.file = file;
         this.delayMillis = delayMillis;
@@ -271,7 +275,8 @@ public class Tailer implements Runnable {
      * @param bufSize buffer size.
      * @return The new tailer
      */
-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufSize) {
+    public static Tailer create(final File file, final TailerListener listener, final long delayMillis,
+                                final boolean end, final int bufSize) {
         return create(file, listener, delayMillis, end, false, bufSize);
     }
 
@@ -286,7 +291,8 @@ public class Tailer implements Runnable {
      * @param bufSize buffer size.
      * @return The new tailer
      */
-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,
+    public static Tailer create(final File file, final TailerListener listener, final long delayMillis,
+                                final boolean end, final boolean reOpen,
             final int bufSize) {
         return create(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufSize);
     }
@@ -303,7 +309,8 @@ public class Tailer implements Runnable {
      * @param bufSize buffer size.
      * @return The new tailer
      */
-    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen
+    public static Tailer create(final File file, final Charset charset, final TailerListener listener,
+                                final long delayMillis, final boolean end, final boolean reOpen
             ,final int bufSize) {
         final Tailer tailer = new Tailer(file, charset, listener, delayMillis, end, reOpen, bufSize);
         final Thread thread = new Thread(tailer);
@@ -321,7 +328,8 @@ public class Tailer implements Runnable {
      * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
      * @return The new tailer
      */
-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {
+    public static Tailer create(final File file, final TailerListener listener, final long delayMillis,
+                                final boolean end) {
         return create(file, listener, delayMillis, end, DEFAULT_BUFSIZE);
     }
 
@@ -335,7 +343,8 @@ public class Tailer implements Runnable {
      * @param reOpen whether to close/reopen the file between chunks
      * @return The new tailer
      */
-    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {
+    public static Tailer create(final File file, final TailerListener listener, final long delayMillis,
+                                final boolean end, final boolean reOpen) {
         return create(file, listener, delayMillis, end, reOpen, DEFAULT_BUFSIZE);
     }
 
@@ -481,6 +490,10 @@ public class Tailer implements Runnable {
         }
     }
 
+    /**
+     * Stops the tailer with an exception
+     * @param e The exception to send to listener
+     */
     private void stop(final Exception e) {
         listener.handle(e);
         stop();
@@ -536,6 +549,9 @@ public class Tailer implements Runnable {
         }
         IOUtils.closeQuietly(lineBuf); // not strictly necessary
         reader.seek(rePos); // Ensure we can re-read if necessary
+
+        listener.endOfFileReached();
+
         return rePos;
     }
 
diff --git a/src/main/java/org/apache/commons/io/input/TailerListener.java b/src/main/java/org/apache/commons/io/input/TailerListener.java
index c58eb64..6906db8 100644
--- a/src/main/java/org/apache/commons/io/input/TailerListener.java
+++ b/src/main/java/org/apache/commons/io/input/TailerListener.java
@@ -64,4 +64,10 @@ public interface TailerListener {
      */
     void handle(Exception ex);
 
+    /**
+     * Called each time the Tailer reaches the end of the file.
+     * <p>
+     * <b>Note:</b> this is called from the tailer thread.
+     */
+    void endOfFileReached();
 }
diff --git a/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java b/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java
index 0b15669..52ee222 100644
--- a/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java
+++ b/src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java
@@ -61,4 +61,9 @@ public class TailerListenerAdapter implements TailerListener {
     public void handle(final Exception ex) {
     }
 
+    /**
+     * Called each time the Tailer reaches the end of the file.
+     */
+    public void endOfFileReached() {
+    }
 }
diff --git a/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java b/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java
index 820eb86..7464c35 100644
--- a/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java
@@ -48,6 +48,11 @@ public class UnixLineEndingInputStream extends InputStream {
         this.ensureLineFeedAtEndOfFile = ensureLineFeedAtEndOfFile;
     }
 
+    /**
+     * Reads the next item from the target, updating internal flags in the process
+     * @return the next int read from the target stream
+     * @throws IOException upon error
+     */
     private int readWithUpdate() throws IOException {
         final int target = this.target.read();
         eofSeen = target == -1;
@@ -86,6 +91,11 @@ public class UnixLineEndingInputStream extends InputStream {
         }
     }
 
+    /**
+     * Handles the eof-handling at the end of the stream
+     * @param previousWasSlashR Indicates if the last seen was a \r
+     * @return The next char to output to the stream
+     */
     private int eofGame(boolean previousWasSlashR) {
         if ( previousWasSlashR || !ensureLineFeedAtEndOfFile ) {
             return -1;
@@ -100,6 +110,7 @@ public class UnixLineEndingInputStream extends InputStream {
 
     /**
      * Closes the stream. Also closes the underlying stream.
+     * @throws IOException upon error
      */
     @Override
     public void close() throws IOException {
diff --git a/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java b/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java
index 8cbb47c..e166518 100644
--- a/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java
@@ -21,6 +21,8 @@ import java.io.InputStream;
 
 /**
  * A filtering input stream that ensures the content will have windows line endings, CRLF.
+ *
+ * @since 2.5
  */
 public class WindowsLineEndingInputStream  extends InputStream {
 
@@ -47,6 +49,11 @@ public class WindowsLineEndingInputStream  extends InputStream {
         this.ensureLineFeedAtEndOfFile = ensureLineFeedAtEndOfFile;
     }
 
+    /**
+     * Reads the next item from the target, updating internal flags in the process
+     * @return the next int read from the target stream
+     * @throws IOException upon error
+     */
     private int readWithUpdate() throws IOException {
         final int target = this.target.read();
         eofSeen = target == -1;
@@ -85,6 +92,11 @@ public class WindowsLineEndingInputStream  extends InputStream {
         }
     }
 
+    /**
+     * Handles the eof-handling at the end of the stream
+     * @return The next char to output to the stream
+     */
+
     private int eofGame() {
         if ( !ensureLineFeedAtEndOfFile ) {
             return -1;
@@ -104,6 +116,7 @@ public class WindowsLineEndingInputStream  extends InputStream {
 
     /**
      * Closes the stream. Also closes the underlying stream.
+     * @throws IOException upon error
      */
     @Override
     public void close() throws IOException {
diff --git a/src/main/java/org/apache/commons/io/input/XmlStreamReader.java b/src/main/java/org/apache/commons/io/input/XmlStreamReader.java
index 78c832d..4415791 100644
--- a/src/main/java/org/apache/commons/io/input/XmlStreamReader.java
+++ b/src/main/java/org/apache/commons/io/input/XmlStreamReader.java
@@ -212,7 +212,8 @@ public class XmlStreamReader extends Reader {
      * @throws XmlStreamReaderException thrown if the charset encoding could not
      *         be determined according to the specs.
      */
-    public XmlStreamReader(final InputStream is, final boolean lenient, final String defaultEncoding) throws IOException {
+    public XmlStreamReader(final InputStream is, final boolean lenient, final String defaultEncoding)
+            throws IOException {
         this.defaultEncoding = defaultEncoding;
         final BOMInputStream bom = new BOMInputStream(new BufferedInputStream(is, BUFFER_SIZE), false, BOMS);
         final BOMInputStream pis = new BOMInputStream(bom, true, XML_GUESS_BYTES);
diff --git a/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java b/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java
index 0edf1d1..2115c22 100644
--- a/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java
+++ b/src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java
@@ -154,7 +154,8 @@ public class FileAlterationObserver implements Serializable {
      * @param fileFilter The file filter or null if none
      * @param caseSensitivity  what case sensitivity to use comparing file names, null means system sensitive
      */
-    public FileAlterationObserver(final String directoryName, final FileFilter fileFilter, final IOCase caseSensitivity) {
+    public FileAlterationObserver(final String directoryName, final FileFilter fileFilter,
+                                  final IOCase caseSensitivity) {
         this(new File(directoryName), fileFilter, caseSensitivity);
     }
 
@@ -197,7 +198,8 @@ public class FileAlterationObserver implements Serializable {
      * @param fileFilter The file filter or null if none
      * @param caseSensitivity  what case sensitivity to use comparing file names, null means system sensitive
      */
-    protected FileAlterationObserver(final FileEntry rootEntry, final FileFilter fileFilter, final IOCase caseSensitivity) {
+    protected FileAlterationObserver(final FileEntry rootEntry, final FileFilter fileFilter,
+                                     final IOCase caseSensitivity) {
         if (rootEntry == null) {
             throw new IllegalArgumentException("Root entry is missing");
         }
@@ -359,6 +361,12 @@ public class FileAlterationObserver implements Serializable {
         return entry;
     }
 
+    /**
+     * List the files
+     * @param file The file to list files for
+     * @param entry the parent entry
+     * @return The child files
+     */
     private FileEntry[] doListFiles(File file, FileEntry entry) {
         final File[] files = listFiles(file);
         final FileEntry[] children = files.length > 0 ? new FileEntry[files.length] : FileEntry.EMPTY_ENTRIES;
diff --git a/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java b/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java
index f44b8ec..944cd4d 100644
--- a/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/AppendableOutputStream.java
@@ -46,6 +46,7 @@ public class AppendableOutputStream <T extends Appendable> extends OutputStream
      * Write a character to the underlying appendable.
      *
      * @param b the character to write
+     * @throws IOException upon error
      */
     @Override
     public void write(int b) throws IOException {
diff --git a/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java b/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java
index 033358a..995ca0d 100644
--- a/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java
@@ -65,6 +65,12 @@ public class ChunkedOutputStream extends FilterOutputStream {
 
     /**
      * Writes the data buffer in chunks to the underlying stream
+     *
+     * @param data the data to write
+     * @param srcOffset the offset
+     * @param length the length of data to write
+     *
+     * @throws IOException if an I/O error occurs.
      */
     @Override
     public void write(byte[] data, int srcOffset, int length) throws IOException {
diff --git a/src/main/java/org/apache/commons/io/output/ChunkedWriter.java b/src/main/java/org/apache/commons/io/output/ChunkedWriter.java
index 881d6b8..d2494f1 100644
--- a/src/main/java/org/apache/commons/io/output/ChunkedWriter.java
+++ b/src/main/java/org/apache/commons/io/output/ChunkedWriter.java
@@ -64,6 +64,11 @@ public class ChunkedWriter extends FilterWriter {
 
     /**
      * writes the data buffer in chunks to the underlying writer
+     * @param data The data
+     * @param srcOffset the offset
+     * @param length the number of bytes to write
+     *
+     * @throws IOException upon error
      */
     @Override
     public void write(char[] data, int srcOffset, int length) throws IOException {
diff --git a/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java b/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java
index 0af4a54..5f689bd 100644
--- a/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java
@@ -131,7 +131,8 @@ public class DeferredFileOutputStream
      * @param suffix Suffix to use for the temporary file.
      * @param directory Temporary file directory.
      */
-    private DeferredFileOutputStream(final int threshold, final File outputFile, final String prefix, final String suffix, final File directory) {
+    private DeferredFileOutputStream(final int threshold, final File outputFile, final String prefix,
+                                     final String suffix, final File directory) {
         super(threshold);
         this.outputFile = outputFile;
 
@@ -176,7 +177,12 @@ public class DeferredFileOutputStream
             outputFile = File.createTempFile(prefix, suffix, directory);
         }
         final FileOutputStream fos = new FileOutputStream(outputFile);
-        memoryOutputStream.writeTo(fos);
+        try {
+            memoryOutputStream.writeTo(fos);
+        } catch (IOException e){
+            fos.close();
+            throw e;
+        }
         currentOutputStream = fos;
         memoryOutputStream = null;
     }
diff --git a/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java b/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java
index 7e33f8d..c054cb5 100644
--- a/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java
+++ b/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java
@@ -75,7 +75,8 @@ public class FileWriterWithEncoding extends Writer {
      * @throws NullPointerException if the file name or encoding is null
      * @throws IOException in case of an I/O error
      */
-    public FileWriterWithEncoding(final String filename, final String encoding, final boolean append) throws IOException {
+    public FileWriterWithEncoding(final String filename, final String encoding, final boolean append)
+            throws IOException {
         this(new File(filename), encoding, append);
     }
 
@@ -100,7 +101,8 @@ public class FileWriterWithEncoding extends Writer {
      * @throws NullPointerException if the file name or encoding is null
      * @throws IOException in case of an I/O error
      */
-    public FileWriterWithEncoding(final String filename, final Charset encoding, final boolean append) throws IOException {
+    public FileWriterWithEncoding(final String filename, final Charset encoding, final boolean append)
+            throws IOException {
         this(new File(filename), encoding, append);
     }
 
@@ -125,7 +127,8 @@ public class FileWriterWithEncoding extends Writer {
      * @throws NullPointerException if the file name or encoding is null
      * @throws IOException in case of an I/O error
      */
-    public FileWriterWithEncoding(final String filename, final CharsetEncoder encoding, final boolean append) throws IOException {
+    public FileWriterWithEncoding(final String filename, final CharsetEncoder encoding, final boolean append)
+            throws IOException {
         this(new File(filename), encoding, append);
     }
 
@@ -202,7 +205,8 @@ public class FileWriterWithEncoding extends Writer {
      * @throws NullPointerException if the file or encoding is null
      * @throws IOException in case of an I/O error
      */
-    public FileWriterWithEncoding(final File file, final CharsetEncoder encoding, final boolean append) throws IOException {
+    public FileWriterWithEncoding(final File file, final CharsetEncoder encoding, final boolean append)
+            throws IOException {
         super();
         this.out = initWriter(file, encoding, append);
     }
diff --git a/src/main/java/org/apache/commons/io/output/LockableFileWriter.java b/src/main/java/org/apache/commons/io/output/LockableFileWriter.java
index c3dbf35..ee74b42 100644
--- a/src/main/java/org/apache/commons/io/output/LockableFileWriter.java
+++ b/src/main/java/org/apache/commons/io/output/LockableFileWriter.java
@@ -21,10 +21,8 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
 import java.io.Writer;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 
 import org.apache.commons.io.Charsets;
 import org.apache.commons.io.FileUtils;
@@ -158,8 +156,8 @@ public class LockableFileWriter extends Writer {
      * @param encoding  the encoding to use, null means platform default
      * @throws NullPointerException if the file is null
      * @throws IOException in case of an I/O error
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     * @throws java.nio.charset.UnsupportedCharsetException
+     *             thrown instead of {@link java.io.UnsupportedEncodingException} in version 2.2 if the encoding is not
      *             supported.
      */
     public LockableFileWriter(final File file, final String encoding) throws IOException {
@@ -214,8 +212,8 @@ public class LockableFileWriter extends Writer {
      * @param lockDir  the directory in which the lock file should be held
      * @throws NullPointerException if the file is null
      * @throws IOException in case of an I/O error
-     * @throws UnsupportedCharsetException
-     *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     * @throws java.nio.charset.UnsupportedCharsetException
+     *             thrown instead of {@link java.io.UnsupportedEncodingException} in version 2.2 if the encoding is not
      *             supported.
      */
     public LockableFileWriter(final File file, final String encoding, final boolean append,
diff --git a/src/main/java/org/apache/commons/io/output/WriterOutputStream.java b/src/main/java/org/apache/commons/io/output/WriterOutputStream.java
index 8fedba0..753833e 100644
--- a/src/main/java/org/apache/commons/io/output/WriterOutputStream.java
+++ b/src/main/java/org/apache/commons/io/output/WriterOutputStream.java
@@ -117,7 +117,8 @@ public class WriterOutputStream extends OutputStream {
      *                         {@link #flush()} or {@link #close()} is called.
      * @since 2.1
      */
-    public WriterOutputStream(final Writer writer, final CharsetDecoder decoder, final int bufferSize, final boolean writeImmediately) {
+    public WriterOutputStream(final Writer writer, final CharsetDecoder decoder, final int bufferSize,
+                              final boolean writeImmediately) {
         this.writer = writer;
         this.decoder = decoder;
         this.writeImmediately = writeImmediately;
@@ -136,7 +137,8 @@ public class WriterOutputStream extends OutputStream {
      *                         output buffer will only be flushed when it overflows or when
      *                         {@link #flush()} or {@link #close()} is called.
      */
-    public WriterOutputStream(final Writer writer, final Charset charset, final int bufferSize, final boolean writeImmediately) {
+    public WriterOutputStream(final Writer writer, final Charset charset, final int bufferSize,
+                              final boolean writeImmediately) {
         this(writer,
              charset.newDecoder()
                     .onMalformedInput(CodingErrorAction.REPLACE)
@@ -170,7 +172,8 @@ public class WriterOutputStream extends OutputStream {
      *                         output buffer will only be flushed when it overflows or when
      *                         {@link #flush()} or {@link #close()} is called.
      */
-    public WriterOutputStream(final Writer writer, final String charsetName, final int bufferSize, final boolean writeImmediately) {
+    public WriterOutputStream(final Writer writer, final String charsetName, final int bufferSize,
+                              final boolean writeImmediately) {
         this(writer, Charset.forName(charsetName), bufferSize, writeImmediately);
     }
 
diff --git a/src/test/java/org/apache/commons/io/input/TailerTest.java b/src/test/java/org/apache/commons/io/input/TailerTest.java
index 26543d2..1d3b706 100644
--- a/src/test/java/org/apache/commons/io/input/TailerTest.java
+++ b/src/test/java/org/apache/commons/io/input/TailerTest.java
@@ -262,6 +262,34 @@ public class TailerTest extends FileBasedTestCase {
         assertEquals("fileRotated should be be called", 1 , listener.rotated);
     }
 
+    public void testTailerEndOfFileReached() throws Exception {
+        // Create & start the Tailer
+        final long delayMillis = 50;
+        final long testDelayMillis = delayMillis * 10;
+        final File file = new File(getTestDirectory(), "tailer1-test.txt");
+        createFile(file, 0);
+        final TestTailerListener listener = new TestTailerListener();
+        final String osname = System.getProperty("os.name");
+        final boolean isWindows = osname.startsWith("Windows");
+        tailer = new Tailer(file, listener, delayMillis, false, isWindows);
+        final Thread thread = new Thread(tailer);
+        thread.start();
+
+        // write a few lines
+        write(file, "line1", "line2", "line3");
+        Thread.sleep(testDelayMillis);
+
+        // write a few lines
+        write(file, "line4", "line5", "line6");
+        Thread.sleep(testDelayMillis);
+
+        // write a few lines
+        write(file, "line7", "line8", "line9");
+        Thread.sleep(testDelayMillis);
+
+        assertEquals("end of file reached 3 times", 3, listener.reachedEndOfFile);
+    }
+
     @Override
     protected void createFile(final File file, final long size)
         throws IOException {
@@ -328,6 +356,7 @@ public class TailerTest extends FileBasedTestCase {
         assertEquals("Expected init to be called", 1 , listener.initialised);
         assertTrue("fileNotFound should be called", listener.notFound > 0);
         assertEquals("fileRotated should be not be called", 0 , listener.rotated);
+        assertEquals("end of file never reached", 0, listener.reachedEndOfFile);
     }
 
     /*
@@ -353,6 +382,7 @@ public class TailerTest extends FileBasedTestCase {
         assertEquals("Expected init to be called", 1, listener.initialised);
         assertTrue("fileNotFound should be called", listener.notFound > 0);
         assertEquals("fileRotated should be not be called", 0, listener.rotated);
+        assertEquals("end of file never reached", 0, listener.reachedEndOfFile);
     }
 
     public void testStopWithNoFileUsingExecutor() throws Exception {
@@ -372,6 +402,7 @@ public class TailerTest extends FileBasedTestCase {
         assertEquals("Expected init to be called", 1 , listener.initialised);
         assertTrue("fileNotFound should be called", listener.notFound > 0);
         assertEquals("fileRotated should be not be called", 0 , listener.rotated);
+        assertEquals("end of file never reached", 0, listener.reachedEndOfFile);
     }
 
     public void testIO335() throws Exception { // test CR behaviour
@@ -418,6 +449,8 @@ public class TailerTest extends FileBasedTestCase {
 
         volatile int initialised = 0;
 
+        volatile int reachedEndOfFile = 0;
+
         public void handle(final String line) {
             lines.add(line);
         }
@@ -445,5 +478,9 @@ public class TailerTest extends FileBasedTestCase {
         public void fileRotated() {
             rotated++; // not atomic, but OK because only updated here.
         }
+
+        public void endOfFileReached() {
+            reachedEndOfFile++; // not atomic, but OK because only updated here.
+        }
     }
 }
