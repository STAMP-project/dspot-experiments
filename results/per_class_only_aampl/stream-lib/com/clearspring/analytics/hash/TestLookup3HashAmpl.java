/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.clearspring.analytics.hash;


/**
 * Tests for lookup3ycs hash functions
 *
 * @author yonik
 */
public class TestLookup3HashAmpl {
    // Test that the java version produces the same output as the C version
    @org.junit.Test
    public void testEqualsLOOKUP3() {
        int[] hashes = new int[]{ -993915435 , 984632515 , -337087325 , 242683635 , -332262248 , 1938054790 , -1976715480 , 63116219 , -27553383 , -1785310939 , -876288062 };
        /**
         * the hash values were generated by adding the following to lookup3.c
         *
         * char* s = "hello world";
         * int len = strlen(s);
         * uint32_t a[len];
         * for (int i=0; i<len; i++) {
         *   a[i]=s[i];
         *   uint32_t result = hashword(a, i+1, i*12345);
         *   printf("0x%.8x\n", result);
         * }
         */
        java.lang.String s = "hello world";
        int[] a = new int[s.length()];
        for (int i = 0; i < (s.length()); i++) {
            a[i] = s.charAt(i);
            int len = i + 1;
            int hash = com.clearspring.analytics.hash.Lookup3Hash.lookup3(a, 0, len, (i * 12345));
            org.junit.Assert.assertEquals(hashes[i], hash);
            int hash2 = com.clearspring.analytics.hash.Lookup3Hash.lookup3ycs(a, 0, len, ((i * 12345) + (len << 2)));
            org.junit.Assert.assertEquals(hashes[i], hash2);
            int hash3 = com.clearspring.analytics.hash.Lookup3Hash.lookup3ycs(s, 0, len, ((i * 12345) + (len << 2)));
            org.junit.Assert.assertEquals(hashes[i], hash3);
        }
    }

    /**
     * test that the hash of the UTF-16 encoded Java String is equal to the hash of the unicode code points
     *
     * @param utf32
     * @param len
     */
    void tstEquiv(int[] utf32, int len) {
        int seed = 100;
        java.lang.StringBuilder sb = new java.lang.StringBuilder();
        for (int i = 0; i < len; i++) {
            sb.appendCodePoint(utf32[i]);
        }
        int hash = com.clearspring.analytics.hash.Lookup3Hash.lookup3(utf32, 0, len, (seed - (len << 2)));
        int hash2 = com.clearspring.analytics.hash.Lookup3Hash.lookup3ycs(utf32, 0, len, seed);
        org.junit.Assert.assertEquals(hash, hash2);
        int hash3 = com.clearspring.analytics.hash.Lookup3Hash.lookup3ycs(sb, 0, sb.length(), seed);
        org.junit.Assert.assertEquals(hash, hash3);
        long hash4 = com.clearspring.analytics.hash.Lookup3Hash.lookup3ycs64(sb, 0, sb.length(), seed);
        org.junit.Assert.assertEquals(((int) (hash4)), hash);
    }

    @org.junit.Test
    public void testHash() {
        java.util.Random r = new java.util.Random(0);
        int[] utf32 = new int[20];
        tstEquiv(utf32, 0);
        utf32[0] = 65536;
        tstEquiv(utf32, 1);
        utf32[0] = 32768;
        tstEquiv(utf32, 1);
        utf32[0] = java.lang.Character.MAX_CODE_POINT;
        tstEquiv(utf32, 1);
        for (int iter = 0; iter < 10000; iter++) {
            int len = r.nextInt(((utf32.length) + 1));
            for (int i = 0; i < len; i++) {
                int codePoint;
                do {
                    codePoint = r.nextInt(((java.lang.Character.MAX_CODE_POINT) + 1));
                } while ((codePoint & 63488) == 55296 );// avoid surrogate code points
                
                utf32[i] = codePoint;
            }
            // System.out.println("len="+len + ","+utf32[0]+","+utf32[1]);
            tstEquiv(utf32, len);
        }
    }
}

