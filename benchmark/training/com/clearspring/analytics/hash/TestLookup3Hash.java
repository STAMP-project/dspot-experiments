/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.clearspring.analytics.hash;


import java.util.Random;
import org.junit.Assert;
import org.junit.Test;


/**
 * Tests for lookup3ycs hash functions
 *
 * @author yonik
 */
public class TestLookup3Hash {
    // Test that the java version produces the same output as the C version
    @Test
    public void testEqualsLOOKUP3() {
        int[] hashes = new int[]{ -993915435, 984632515, -337087325, 242683635, -332262248, 1938054790, -1976715480, 63116219, -27553383, -1785310939, -876288062 };
        /**
         * * the hash values were generated by adding the following to lookup3.c
         *
         * char* s = "hello world";
         * int len = strlen(s);
         * uint32_t a[len];
         * for (int i=0; i<len; i++) {
         *   a[i]=s[i];
         *   uint32_t result = hashword(a, i+1, i*12345);
         *   printf("0x%.8x\n", result);
         * }
         */
        String s = "hello world";
        int[] a = new int[s.length()];
        for (int i = 0; i < (s.length()); i++) {
            a[i] = s.charAt(i);
            int len = i + 1;
            int hash = Lookup3Hash.lookup3(a, 0, len, (i * 12345));
            Assert.assertEquals(hashes[i], hash);
            int hash2 = Lookup3Hash.lookup3ycs(a, 0, len, ((i * 12345) + (len << 2)));
            Assert.assertEquals(hashes[i], hash2);
            int hash3 = Lookup3Hash.lookup3ycs(s, 0, len, ((i * 12345) + (len << 2)));
            Assert.assertEquals(hashes[i], hash3);
        }
    }

    @Test
    public void testHash() {
        Random r = new Random(0);
        int[] utf32 = new int[20];
        tstEquiv(utf32, 0);
        utf32[0] = 65536;
        tstEquiv(utf32, 1);
        utf32[0] = 32768;
        tstEquiv(utf32, 1);
        utf32[0] = Character.MAX_CODE_POINT;
        tstEquiv(utf32, 1);
        for (int iter = 0; iter < 10000; iter++) {
            int len = r.nextInt(((utf32.length) + 1));
            for (int i = 0; i < len; i++) {
                int codePoint;
                do {
                    codePoint = r.nextInt(((Character.MAX_CODE_POINT) + 1));
                } while ((codePoint & 63488) == 55296 );// avoid surrogate code points

                utf32[i] = codePoint;
            }
            // System.out.println("len="+len + ","+utf32[0]+","+utf32[1]);
            tstEquiv(utf32, len);
        }
    }
}

