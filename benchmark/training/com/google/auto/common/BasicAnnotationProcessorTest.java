/**
 * Copyright (C) 2014 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.auto.common;


import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.SetMultimap;
import com.google.testing.compile.JavaFileObjects;
import java.lang.annotation.Annotation;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Set;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;


@RunWith(JUnit4.class)
public class BasicAnnotationProcessorTest {
    @Retention(RetentionPolicy.SOURCE)
    public @interface RequiresGeneratedCode {}

    /**
     * Rejects elements unless the class generated by {@link GeneratesCode}'s processor is present.
     */
    private static final class RequiresGeneratedCodeProcessor extends BasicAnnotationProcessor {
        int rejectedRounds;

        final ImmutableList.Builder<ImmutableSetMultimap<Class<? extends Annotation>, Element>> processArguments = ImmutableList.builder();

        @Override
        public SourceVersion getSupportedSourceVersion() {
            return SourceVersion.latestSupported();
        }

        @Override
        protected Iterable<? extends ProcessingStep> initSteps() {
            return ImmutableSet.of(new ProcessingStep() {
                @Override
                public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
                    processArguments.add(ImmutableSetMultimap.copyOf(elementsByAnnotation));
                    TypeElement requiredClass = processingEnv.getElementUtils().getTypeElement("test.SomeGeneratedClass");
                    if (requiredClass == null) {
                        (rejectedRounds)++;
                        return ImmutableSet.copyOf(elementsByAnnotation.values());
                    }
                    BasicAnnotationProcessorTest.generateClass(processingEnv.getFiler(), "GeneratedByRequiresGeneratedCodeProcessor");
                    return ImmutableSet.of();
                }

                @Override
                public Set<? extends Class<? extends Annotation>> annotations() {
                    return ImmutableSet.of(BasicAnnotationProcessorTest.RequiresGeneratedCode.class);
                }
            }, new ProcessingStep() {
                @Override
                public Set<? extends Class<? extends Annotation>> annotations() {
                    return ImmutableSet.of(BasicAnnotationProcessorTest.AnAnnotation.class);
                }

                @Override
                public Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
                    return ImmutableSet.of();
                }
            });
        }

        ImmutableList<ImmutableSetMultimap<Class<? extends Annotation>, Element>> processArguments() {
            return processArguments.build();
        }
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface GeneratesCode {}

    /**
     * Generates a class called {@code test.SomeGeneratedClass}.
     */
    public class GeneratesCodeProcessor extends BasicAnnotationProcessor {
        @Override
        public SourceVersion getSupportedSourceVersion() {
            return SourceVersion.latestSupported();
        }

        @Override
        protected Iterable<? extends ProcessingStep> initSteps() {
            return ImmutableSet.of(new ProcessingStep() {
                @Override
                public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
                    BasicAnnotationProcessorTest.generateClass(processingEnv.getFiler(), "SomeGeneratedClass");
                    return ImmutableSet.of();
                }

                @Override
                public Set<? extends Class<? extends Annotation>> annotations() {
                    return ImmutableSet.of(BasicAnnotationProcessorTest.GeneratesCode.class);
                }
            });
        }
    }

    public @interface AnAnnotation {}

    /**
     * When annotating a type {@code Foo}, generates a class called {@code FooXYZ}.
     */
    public class AnAnnotationProcessor extends BasicAnnotationProcessor {
        @Override
        public SourceVersion getSupportedSourceVersion() {
            return SourceVersion.latestSupported();
        }

        @Override
        protected Iterable<? extends ProcessingStep> initSteps() {
            return ImmutableSet.of(new ProcessingStep() {
                @Override
                public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
                    for (Element element : elementsByAnnotation.values()) {
                        BasicAnnotationProcessorTest.generateClass(processingEnv.getFiler(), ((element.getSimpleName()) + "XYZ"));
                    }
                    return ImmutableSet.of();
                }

                @Override
                public Set<? extends Class<? extends Annotation>> annotations() {
                    return ImmutableSet.of(BasicAnnotationProcessorTest.AnAnnotation.class);
                }
            });
        }
    }

    @Test
    public void properlyDefersProcessing_typeElement() {
        JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA", "package test;", "", ("@" + (BasicAnnotationProcessorTest.RequiresGeneratedCode.class.getCanonicalName())), "public class ClassA {", "  SomeGeneratedClass sgc;", "}");
        JavaFileObject classBFileObject = JavaFileObjects.forSourceLines("test.ClassB", "package test;", "", ("@" + (BasicAnnotationProcessorTest.GeneratesCode.class.getCanonicalName())), "public class ClassB {}");
        BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor = new BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor();
        assertAbout(javaSources()).that(ImmutableList.of(classAFileObject, classBFileObject)).processedWith(requiresGeneratedCodeProcessor, new BasicAnnotationProcessorTest.GeneratesCodeProcessor()).compilesWithoutError().and().generatesFileNamed(StandardLocation.SOURCE_OUTPUT, "test", "GeneratedByRequiresGeneratedCodeProcessor.java");
        assertThat(requiresGeneratedCodeProcessor.rejectedRounds).isEqualTo(0);
    }

    @Test
    public void properlyDefersProcessing_nestedTypeValidBeforeOuterType() {
        JavaFileObject source = JavaFileObjects.forSourceLines("test.ValidInRound2", "package test;", "", ("@" + (BasicAnnotationProcessorTest.AnAnnotation.class.getCanonicalName())), "public class ValidInRound2 {", "  ValidInRound1XYZ vir1xyz;", ("  @" + (BasicAnnotationProcessorTest.AnAnnotation.class.getCanonicalName())), "  static class ValidInRound1 {}", "}");
        assertAbout(javaSource()).that(source).processedWith(new BasicAnnotationProcessorTest.AnAnnotationProcessor()).compilesWithoutError().and().generatesFileNamed(StandardLocation.SOURCE_OUTPUT, "test", "ValidInRound2XYZ.java");
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ReferencesAClass {
        Class<?> value();
    }

    @Test
    public void properlyDefersProcessing_packageElement() {
        JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA", "package test;", "", ("@" + (BasicAnnotationProcessorTest.GeneratesCode.class.getCanonicalName())), "public class ClassA {", "}");
        JavaFileObject packageFileObject = JavaFileObjects.forSourceLines("test.package-info", ("@" + (BasicAnnotationProcessorTest.RequiresGeneratedCode.class.getCanonicalName())), (("@" + (BasicAnnotationProcessorTest.ReferencesAClass.class.getCanonicalName())) + "(SomeGeneratedClass.class)"), "package test;");
        BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor = new BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor();
        assertAbout(javaSources()).that(ImmutableList.of(classAFileObject, packageFileObject)).processedWith(requiresGeneratedCodeProcessor, new BasicAnnotationProcessorTest.GeneratesCodeProcessor()).compilesWithoutError().and().generatesFileNamed(StandardLocation.SOURCE_OUTPUT, "test", "GeneratedByRequiresGeneratedCodeProcessor.java");
        assertThat(requiresGeneratedCodeProcessor.rejectedRounds).isEqualTo(0);
    }

    @Test
    public void properlyDefersProcessing_argumentElement() {
        JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA", "package test;", "", "public class ClassA {", "  SomeGeneratedClass sgc;", (("  public void myMethod(@" + (BasicAnnotationProcessorTest.RequiresGeneratedCode.class.getCanonicalName())) + " int myInt)"), "  {}", "}");
        JavaFileObject classBFileObject = JavaFileObjects.forSourceLines("test.ClassB", "package test;", "", "public class ClassB {", (("  public void myMethod(@" + (BasicAnnotationProcessorTest.GeneratesCode.class.getCanonicalName())) + " int myInt) {}"), "}");
        BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor = new BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor();
        assertAbout(javaSources()).that(ImmutableList.of(classAFileObject, classBFileObject)).processedWith(requiresGeneratedCodeProcessor, new BasicAnnotationProcessorTest.GeneratesCodeProcessor()).compilesWithoutError().and().generatesFileNamed(StandardLocation.SOURCE_OUTPUT, "test", "GeneratedByRequiresGeneratedCodeProcessor.java");
        assertThat(requiresGeneratedCodeProcessor.rejectedRounds).isEqualTo(0);
    }

    @Test
    public void properlyDefersProcessing_rejectsElement() {
        JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA", "package test;", "", ("@" + (BasicAnnotationProcessorTest.RequiresGeneratedCode.class.getCanonicalName())), "public class ClassA {", ("  @" + (BasicAnnotationProcessorTest.AnAnnotation.class.getCanonicalName())), "  public void method() {}", "}");
        JavaFileObject classBFileObject = JavaFileObjects.forSourceLines("test.ClassB", "package test;", "", ("@" + (BasicAnnotationProcessorTest.GeneratesCode.class.getCanonicalName())), "public class ClassB {}");
        BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor = new BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor();
        assertAbout(javaSources()).that(ImmutableList.of(classAFileObject, classBFileObject)).processedWith(requiresGeneratedCodeProcessor, new BasicAnnotationProcessorTest.GeneratesCodeProcessor()).compilesWithoutError().and().generatesFileNamed(StandardLocation.SOURCE_OUTPUT, "test", "GeneratedByRequiresGeneratedCodeProcessor.java");
        assertThat(requiresGeneratedCodeProcessor.rejectedRounds).isEqualTo(1);
        // Re b/118372780: Assert that the right deferred elements are passed back, and not any enclosed
        // elements annotated with annotations from a different step.
        assertThat(requiresGeneratedCodeProcessor.processArguments()).comparingElementsUsing(BasicAnnotationProcessorTest.setMultimapValuesByString()).containsExactly(ImmutableSetMultimap.of(BasicAnnotationProcessorTest.RequiresGeneratedCode.class, "test.ClassA"), ImmutableSetMultimap.of(BasicAnnotationProcessorTest.RequiresGeneratedCode.class, "test.ClassA")).inOrder();
    }

    @Test
    public void reportsMissingType() {
        JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA", "package test;", "", ("@" + (BasicAnnotationProcessorTest.RequiresGeneratedCode.class.getCanonicalName())), "public class ClassA {", "  SomeGeneratedClass bar;", "}");
        assertAbout(javaSources()).that(ImmutableList.of(classAFileObject)).processedWith(new BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor()).failsToCompile().withErrorContaining(BasicAnnotationProcessorTest.RequiresGeneratedCodeProcessor.class.getCanonicalName()).in(classAFileObject).onLine(4);
    }
}

