/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.harmony.tests.java.lang;


import junit.framework.TestCase;


// TODO(kstanger): Some tests are skipped on armv7 devices due to imprecise
// floating point operations. Fix these to allow some tolerance for imprecise
// results.
public class DoubleTest extends TestCase {
    private static final long[] rawBitsFor3_4en324ToN1 = new long[]{ 1L, 7L, 69L, 688L, 6882L, 68817L, 688168L, 6881677L, 68816766L, 688167661L, 6881676612L, 68816766124L, 688167661245L, 6881676612449L, 68816766124486L, 688167661244856L, 6881676612448561L, 22112894647672189L, 36901507245068910L, 51756383590549258L, 66947279301871820L, 81811496256583040L, 96634870786515680L, 111786389228403608L, 126724438563304767L, 141517049601491598L, 156630113678697266L, 171640264947377663L, 186402833513156479L, 201478344499852127L, 216558907813238811L, 231292138027056674L, 246330976073801131L, 261480301149596299L, 276184880629077293L, 291187905257900665L, 306404380492297867L, 321080980739028014L, 336049031326912826L, 351331082888069828L, 365980359665316725L, 380914255916347474L, 396203926509608039L, 410882940560685504L, 425783482967132208L, 441031461254662717L, 455788648378984038L, 470656618671579135L, 485863881816795135L, 500697409832956159L, 515533571420618047L, 530701073684667535L, 545609153353015770L, 560414251752266320L, 575542925030801636L, 590523809046988942L, 605298572301306546L, 620389326648675679L, 635441308660799579L, 650186447750143602L, 665240171891295758L, 680361585540076489L, 695077794780813499L, 710095356611206890L, 725284574592660306L, 739972532028117031L, 754954779101910064L, 770210212251989150L, 784870580033851846L, 799818340040652343L, 815125340328625093L, 829771861202117211L, 844685942432557810L, 859950844250080687L, 874676299755666317L, 889557491556067952L, 904781281586042124L, 919583821693281576L, 934432894909660786L, 949616536709606926L, 964494354748148937L, 979312062159818747L, 994456496703878138L, 1009407828347207804L, 1024194905090216091L, 1039301051298448578L, 1054324173571453689L, 1069081337552097208L, 1084150092807373733L, 1099243323117171271L, 1113971275415817945L, 1129003516068598416L, 1144165211258076058L, 1158864636523522688L, 1173861218384803104L, 1189089773808343348L, 1203761340642930561L, 1218723099465636705L, 1234016948086503709L, 1248661309422204772L, 1263589061371303229L, 1278871051587148428L, 1293564466345879704L, 1308459008457470654L, 1323699486376431469L, 1338470736691820964L, 1353332847321470989L, 1368532785888005649L, 1383380047489194186L, 1398210486749761277L, 1413370836104942268L, 1428292327477418934L, 1443091837666615971L, 1458213525682584396L, 1473207507066084623L, 1487976813084021843L, 1503060745885915496L, 1518125518295805921L, 1532865328052747225L, 1547912390528395984L, 1563046294799995586L, 1577757299614558066L, 1592768355912233295L, 1607969771767533265L, 1622652646755553926L, 1637628540770051879L, 1652895885906309240L, 1667551290360597654L, 1682492846207930300L, 1697792091296568235L, 1712453153168813131L, 1727361175649773406L, 1742618504030445877L, 1757358159730126017L, 1772233434782988273L, 1787449828878538222L, 1802266236362823093L, 1817109531505433378L, 1832285950713168362L, 1847177311112106290L, 1861989375873611135L, 1877126757104964319L, 1892091313709618123L, 1906872880052074686L, 1921972138259617517L, 1937008175533915732L, 1951759958264020457L, 1966821986956123492L, 1981927829571871326L, 1996650526743038710L, 2011676198486470068L, 2026850210380977296L, 2041544503685994932L, 2056534670596739105L, 2071775254052534805L, 2086441809207015578L, 2101397303429588673L, 2116702898175705144L, 2131342365292552262L, 2146263999468083288L, 2161538342466969198L, 2176246095757499141L, 2191134663480840646L, 2206367673414489655L, 2221152926202338787L, 2236009202468463963L, 2251201848080592562L, 2266062783971292463L, 2280887525611229819L, 2296040752940623642L, 2310975598111451248L, 2325769544218002060L, 2340884277130662703L, 2355891299332865022L, 2370655171676343037L, 2385732312385162684L, 2400809819969566870L, 2415544323403794107L, 2430584752976050282L, 2445731093941510978L, 2460436916800298003L, 2475441495653253911L, 2490655056717402607L, 2505332871201736298L, 2520302439586625541L, 2535581645278399235L, 2550232107834555844L, 2565167486309223733L, 2580459009682030722L, 2595134549771458641L, 2610036539661925989L, 2625286327304482303L, 2640040121888130239L, 2654909505739339247L, 2670118535832822635L, 2684948750820982307L, 2699786292836978091L, 2714955520636444950L, 2729860364925885614L, 2744666811399680985L, 2759797169771397328L, 2774774894237870210L, 2789550973971235490L, 2804643373917414219L, 2819692270431770127L, 2834438695145184147L, 2849494026316423799L, 2864612426783790475L, 2879329891516783341L, 2894349022712496552L, 2909535298133975305L, 2924224481636088140L, 2939208261293201310L, 2954460820849555139L, 2969122385962136692L, 2984071642632335761L, 2999380513749556725L, 3014023526818208441L, 3028939069633999207L, 3044205798433209793L, 3058927828348130969L, 3073810447477976127L, 3089036021669754703L, 3103835216473610897L, 3118685683566399797L, 3133871067711858051L, 3148745618852564850L, 3163564687471665998L, 3178710823525014562L, 3193658964838427029L, 3208447370885567482L, 3223555178723965177L, 3238575185440410524L, 3253333647569620611L, 3268404025510605347L, 3283494213284699990L, 3298223433306556203L, 3313257258613348598L, 3328415982576553882L, 3343116645852947328L, 3358114775227911265L, 3373340429063294908L, 3388013204892947371L, 3402976474959485078L, 3418267489998167902L, 3432913031993112373L, 3447842259766265091L, 3463126094762178115L, 3477816050558282218L, 3492712033904301157L, 3507954313366296958L, 3522722185788495855L, 3537585703873641962L, 3552787401759546725L, 3567631364636916319L, 3582463178365741303L, 3597625245806244661L, 3612543515768741889L, 3627344368212097025L, 3642467734045763073L, 3657458569521080257L, 3672229186334093745L, 3687314757629832733L, 3702376457863763154L, 3717117547694021127L, 3732166210261315721L, 3747297114361079381L, 3762009369247240171L, 3777021988134413285L, 3792220474134404719L, 3806904569895470603L, 3821881989876275086L, 3837146473825707705L, 3851803070441173095L, 3866746116489976961L, 3882047224330453921L, 3896704793543000645L, 3911614271298835158L, 3926873418773100427L, 3941609663672294071L, 3956486359892025701L, 3971704530446162366L, 3986517607070597143L, 4001362290071478300L, 4016540444102051875L, 4031428551708167446L, 4046241971800014940L, 4061381047194296435L, 4076342427243459656L, 4091125317150703962L, 4106226229814231472L, 4121259164983558414L, 4136012240257401169L, 4151075884629176742L, 4166178697845538568L, 4180902657266450121L, 4195929906822061692L, 4211100960318731021L, 4225796486289514449L, 4240788194032465861L, 4256025888427872987L, 4270693647357515666L, 4285650646299041142L, 4300953419697121898L, 4315594062375650564L, 4330517166003283526L, 4345793345817296855L, 4360497655079462886L, 4375387657814622688L, 4390622461513044568L, 4405404350991944567L, 4420262028636798549L, 4435456425972338154L, 4450314077381642418L, 4465140187555494623L, 4480295125552282006L, 4495226763221746686L, 4510022045787198717L, 4525138449273485885L, 4540142339150138470L, 4554907516629262208L, 4569986288757639007L, 4585060737430373532L, 4599796515411129795L, 4614838538166547251L };

    private static final long[] rawBitsFor1_2e0To309 = new long[]{ 4608083138725491507L, 4622945017495814144L, 4638144666238189568L, 4652992471259676672L, 4667822684095119360L, 4682982750418894848L, 4697904772475256832L, 4712704061546168320L, 4727825473164279808L, 4742819972793761792L, 4757589062875873280L, 4772672725757984768L, 4787738004267466752L, 4802477603149578240L, 4817524402031689728L, 4832658800541171712L, 4847369599423283200L, 4862380398305394688L, 4877582296814876672L, 4892264970696988160L, 4907240613329099648L, 4922508429807331632L, 4937163637869130620L, 4952104948225851483L, 4967403886451224690L, 4982065523692090951L, 4996973306436125657L, 5012230335145641167L, 5026970552728740609L, 5041845593663511490L, 5057061695111447218L, 5071878651310008751L, 5086721717821670427L, 5101897851240719650L, 5116789747493443381L, 5131601588982537475L, 5146738691123377219L, 5161703771022743722L, 5176485119325736661L, 5191584104983949962L, 5206620653288241046L, 5221372223089182076L, 5236433985619830490L, 5251540327288305737L, 5266262816520836699L, 5281288228340972529L, 5296462727591658871L, 5311156817831601877L, 5326146730911002762L, 5341387790300567126L, 5356054147149310956L, 5371009393489712870L, 5386315453014900304L, 5400954726473801188L, 5415876118576899421L, 5431150158985244340L, 5445858479633038641L, 5460746810957519997L, 5475979525392593820L, 5490765332240271426L, 5505621377648134738L, 5520813734687436006L, 5535675211652187152L, 5550499727844603156L, 5565652673364595289L, 5580588046928051064L, 5595381772871006806L, 5610496230579173611L, 5625503768789801875L, 5640267426129769080L, 5655344298084200213L, 5670422309583082861L, 5685156603052944073L, 5700196770169742715L, 5715343603239186285L, 5730049221054647112L, 5745053543603445274L, 5760267585237889744L, 5774945199484600196L, 5789914517572460389L, 5805194192571163551L, 5819844459582766215L, 5834779593626741673L, 5850070811461183123L, 5864746924435046428L, 5879648675623665699L, 5894898164888911916L, 5909652518930016283L, 5924521669673951778L, 5939730408383343275L, 5954561169716675243L, 5969398484088849237L, 5984567427333538859L, 5999472805163186843L, 6014279029328562497L, 6029409109814754194L, 6044387355316585787L, 6059163217951884938L, 6074255346525481004L, 6089304751863429404L, 6104050964567013219L, 6119106030725965115L, 6134224928091371333L, 6148942185783514390L, 6163961058178165340L, 6179147818851635833L, 6193836800165418776L, 6208820327087119582L, 6224073360522371595L, 6238734728185412237L, 6253683738043685169L, 6268992300645998461L, 6283635892180102062L, 6298551193968621209L, 6313817621483742272L, 6328540216306331304L, 6343422600057981522L, 6358647880027016422L, 6373447626498517008L, 6388297863729787412L, 6403482960548347545L, 6418358050426988320L, 6433176894571950312L, 6448322750032624929L, 6463271417457301045L, 6478059604291414978L, 6493167138113529523L, 6508187658610505776L, 6522945906664494652L, 6538016017011452874L, 6553106706524347231L, 6567835717488370230L, 6582869281472871108L, 6598028495415372986L, 6612728954533726185L, 6627726828711139811L, 6642952961041930286L, 6657625537498496569L, 6672588558348676552L, 6687880040668030109L, 6702525387962695108L, 6717454372360498485L, 6732737903137224834L, 6747428429344303953L, 6762324175019083302L, 6777566157392029615L, 6792334586856196302L, 6807197872840522497L, 6822399280600402369L, 6837243787464068633L, 6852075374531936671L, 6867237158646243847L, 6882155959845358916L, 6896956590940123285L, 6912079680088050875L, 6927071034349127669L, 6941841435001407986L, 6956926736096230510L, 6971988942956879301L, 6986729821692671286L, 7001778220391883396L, 7016909619244301714L, 7031621667983523063L, 7046634029187021876L, 7061832998343902625L, 7076516892789597961L, 7091494061126189259L, 7106759016908521599L, 7121415416926945439L, 7136358217229447366L, 7151659017887046904L, 7166317163067488795L, 7181226400836700322L, 7196485248327686858L, 7211222055695528126L, 7226098517553323246L, 7241316395155039274L, 7256130021065262746L, 7270974475197065280L, 7286152343141290577L, 7301040987159309170L, 7315854183746197071L, 7330992979759279075L, 7345954883648191342L, 7360737555288873545L, 7375838195119198427L, 7390871641850780297L, 7405624503973683499L, 7420687881906784630L, 7435791194695661034L, 7450514945961358180L, 7465541935322951741L, 7480713476683404838L, 7495408799377611696L, 7510400253024842396L, 7525638423849725858L, 7540305984267086730L, 7555262735068259948L, 7570565973729501188L, 7585206422548379653L, 7600129283851449862L, 7615405160759759751L, 7630110037970119733L, 7644999804060198722L, 7660234311952269586L, 7675016756068077739L, 7689874202614219990L, 7705068311076369932L, 7719926504123279815L, 7734752388614796345L, 7749907044508664135L, 7764839211121103053L, 7779634273293649152L, 7794750401288803904L, 7809754807711329768L, 7824519769963006306L, 7839598273057074106L, 7854673226169138004L, 7869408793966840361L, 7884450553993440436L, 7899594400357006320L, 7914301262633249517L, 7929307140758025640L, 7944518265687511433L, 7959197095227954667L, 7974167932432980838L, 7989444759086997792L, 8004096212908886375L, 8019032830465719233L, 8034325902691232434L, 8048998538681836207L, 8063901738613480283L, 8079153038807507506L, 8093903997357147487L, 8108774562889193143L, 8123985070083722340L, 8138812515507421119L, 8153651211508608942L, 8168821881789565850L, 8183724021426212672L, 8198531594838672144L, 8213663361883718612L, 8228638445087697509L, 8243415625347101950L, 8258509400950829629L, 8273555718107281254L, 8288303217553155392L, 8303359892139970192L, 8318475773703133466L, 8333194287979544416L, 8348214731104530233L, 8363398546658622851L, 8378088755105479908L, 8393073815943523357L, 8408323973285632914L, 8422986539320816247L, 8437937047144267541L, 8453247482203053786L, 8467887562881270600L, 8482804327526409242L, 8498072583612304673L, 8512791749864691764L, 8527675562187259457L, 8542902627869941202L, 8557699026128353955L, 8572550658448410956L, 8587737499127954335L, 8602609319267251523L, 8617429525803606676L, 8632577084253522745L, 8647522558573371140L, 8662312075867829957L, 8677421272765375606L, 8692438674995918538L, 8707198222327587964L, 8722269956771646875L, 8737357601102477441L, 8752087880892360353L, 8767123030909186121L, 8782279271041078830L, 8796980969247185849L, 8811980392284291752L, 8827203620503159209L, 8841877407006360083L, 8856841940414833304L, 8872130586687387039L, 8886777115668218631L, 8901707577173730248L, 8916992954335091898L, 8931680018570979828L, 8946577206733755506L, 8961820992216697230L, 8976586040849622521L, 8991450735513632631L, 9006653904123117397L, 9021495109393774485L, 9036328072125396346L, 9051491575819395801L, 9066407152806587847L, 9081209127322986809L, 9096333895747957640L, 9111322101364578357L, 9126093813952048706L, 9141180754965858770L, 9156239886978405923L, 9170982046900906924L, 9186032047083505303L, 9201160443154574367L, 9215873743052691238L, 9218868437227405312L };

    /**
     * java.lang.Double#Double(double)
     */
    public void test_ConstructorD() {
        Double d = new Double(39089.88888888889);
        TestCase.assertEquals("Created incorrect double", 39089.88888888889, d.doubleValue(), 0.0);
    }

    /**
     * java.lang.Double#Double(java.lang.String)
     */
    public void test_ConstructorLjava_lang_String() {
        Double d = new Double("39089.88888888888888888888888888888888");
        TestCase.assertEquals("Created incorrect double", 39089.88888888889, d.doubleValue(), 0.0);
        // Regression test for HARMONY-489
        try {
            d = new Double("1E+-20");
            TestCase.fail("new Double(\"1E+-20\") should throw exception");
        } catch (NumberFormatException e) {
            // expected
        }
        // Regression test for HARMONY-329
        d = Double.parseDouble("-1.233999999999999965116738099630936817275852021384209929081813042837802886790127428328465579708849276001782791006814286802871737087810957327493372866733334925806221045495205250590286471187577636646208155890426896101636282423463443661040209738873506655844025580428394216030152374941053494694642722606658935546875E-112");
        if (!(System.getProperty("os.arch").equals("armv7"))) {
            TestCase.assertEquals("Failed to parse long string", (-1.234E-112), d.doubleValue(), 0.0);
        }
    }

    /**
     * java.lang.Double#byteValue()
     */
    public void test_byteValue() {
        Double d = new Double(1923311.47712);
        TestCase.assertEquals("Returned incorrect byte value", ((byte) (-17)), d.byteValue());
    }

    /**
     * java.lang.Double#compareTo(java.lang.Double)
     * java.lang.Double#compare(double, double)
     */
    public void test_compare() {
        if (System.getProperty("os.arch").equals("armv7")) {
            return;
        }
        double[] values = new double[]{ Double.NEGATIVE_INFINITY, -(Double.MAX_VALUE), -2.0, -(Double.MIN_VALUE), -0.0, 0.0, Double.MIN_VALUE, 2.0, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN };
        for (int i = 0; i < (values.length); i++) {
            double d1 = values[i];
            TestCase.assertTrue(("compare() should be equal: " + d1), ((Double.compare(d1, d1)) == 0));
            Double D1 = new Double(d1);
            TestCase.assertTrue(("compareTo() should be equal: " + d1), ((D1.compareTo(D1)) == 0));
            for (int j = i + 1; j < (values.length); j++) {
                double d2 = values[j];
                TestCase.assertTrue(((("compare() " + d1) + " should be less ") + d2), ((Double.compare(d1, d2)) == (-1)));
                TestCase.assertTrue(((("compare() " + d2) + " should be greater ") + d1), ((Double.compare(d2, d1)) == 1));
                Double D2 = new Double(d2);
                TestCase.assertTrue(((("compareTo() " + d1) + " should be less ") + d2), ((D1.compareTo(D2)) == (-1)));
                TestCase.assertTrue(((("compareTo() " + d2) + " should be greater ") + d1), ((D2.compareTo(D1)) == 1));
            }
        }
        try {
            new Double(0.0).compareTo(null);
            TestCase.fail("No NPE");
        } catch (NullPointerException e) {
        }
    }

    /**
     * java.lang.Double#doubleToLongBits(double)
     */
    public void test_doubleToLongBitsD() {
        // Test for method long java.lang.Double.doubleToLongBits(double)
        Double d = new Double(Double.MAX_VALUE);
        long lbits = Double.doubleToLongBits(d.doubleValue());
        double r = Double.longBitsToDouble(lbits);
        TestCase.assertTrue("Bit conversion failed", ((d.doubleValue()) == r));
    }

    /**
     * java.lang.Double#doubleToRawLongBits(double)
     */
    public void test_doubleToRawLongBitsD() {
        long l = 9221120237041091794L;
        double d = Double.longBitsToDouble(l);
        TestCase.assertTrue("Wrong raw bits", ((Double.doubleToRawLongBits(d)) == l));
    }

    /**
     * java.lang.Double#doubleValue()
     */
    public void test_doubleValue() {
        TestCase.assertEquals("Incorrect double value returned", 1.0E15, new Double(1.0E15).doubleValue(), 0.0);
    }

    /**
     * java.lang.Double#floatValue()
     */
    public void test_floatValue() {
        // Test for method float java.lang.Double.floatValue()
        TestCase.assertTrue("Incorrect float value returned ", ((Math.abs(((new Double(1.0E15).floatValue()) - 9.9999999E14F))) < 1));
    }

    /**
     * java.lang.Double#hashCode()
     */
    public void test_hashCode() {
        // Test for method int java.lang.Double.hashCode()
        for (int i = -1000; i < 1000; i++) {
            Double d = new Double(i);
            Double dd = new Double(i);
            TestCase.assertTrue("Should not be identical ", (d != dd));
            TestCase.assertTrue("Should be equals 1 ", d.equals(dd));
            TestCase.assertTrue("Should be equals 2 ", dd.equals(d));
            TestCase.assertTrue("Should have identical values ", ((dd.doubleValue()) == (d.doubleValue())));
            TestCase.assertTrue("Invalid hash for equal but not identical doubles ", ((d.hashCode()) == (dd.hashCode())));
        }
        TestCase.assertEquals("Magic assumption hasCode (0.0) = 0 failed", 0, new Double(0.0).hashCode());
    }

    /**
     * java.lang.Double#intValue()
     */
    public void test_intValue() {
        // Test for method int java.lang.Double.intValue()
        Double d = new Double(1923311.47712);
        TestCase.assertEquals("Returned incorrect int value", 1923311, d.intValue());
    }

    /**
     * java.lang.Double#isInfinite()
     */
    public void test_isInfinite() {
        // Test for method boolean java.lang.Double.isInfinite()
        TestCase.assertTrue("NEGATIVE_INFINITY returned false", new Double(Double.NEGATIVE_INFINITY).isInfinite());
        TestCase.assertTrue("POSITIVE_INFINITY returned false", new Double(Double.POSITIVE_INFINITY).isInfinite());
        TestCase.assertTrue("Non infinite number returned true", (!(new Double(1000).isInfinite())));
    }

    /**
     * java.lang.Double#isInfinite(double)
     */
    public void test_isInfiniteD() {
        // Test for method boolean java.lang.Double.isInfinite(double)
        TestCase.assertTrue(Double.isInfinite(Double.NEGATIVE_INFINITY));
        TestCase.assertTrue(Double.isInfinite(Double.POSITIVE_INFINITY));
        TestCase.assertFalse(Double.isInfinite(Double.MAX_VALUE));
        TestCase.assertFalse(Double.isInfinite(Double.MIN_VALUE));
        TestCase.assertFalse(Double.isInfinite(Double.NaN));
        TestCase.assertFalse(Double.isInfinite(0.0));
    }

    /**
     * java.lang.Double#isFinite(double)
     */
    public void test_isFiniteD() {
        // Test for method boolean java.lang.Double.isFinite(double)
        TestCase.assertFalse(Double.isFinite(Double.NEGATIVE_INFINITY));
        TestCase.assertFalse(Double.isFinite(Double.POSITIVE_INFINITY));
        TestCase.assertTrue(Double.isFinite(Double.MAX_VALUE));
        TestCase.assertTrue(Double.isFinite(Double.MIN_VALUE));
        TestCase.assertFalse(Double.isFinite(Double.NaN));
        TestCase.assertTrue(Double.isFinite(0.0));
    }

    /**
     * java.lang.Double#isNaN()
     */
    public void test_isNaN() {
        // Test for method boolean java.lang.Double.isNaN()
        Double d = new Double((0.0 / 0.0));
        TestCase.assertTrue("NAN returned false", d.isNaN());
        d = new Double(0);
        TestCase.assertTrue("Non NAN returned true", (!(d.isNaN())));
    }

    /**
     * java.lang.Double#isNaN(double)
     */
    public void test_isNaND() {
        // Test for method boolean java.lang.Double.isNaN(double)
        Double d = new Double((0.0 / 0.0));
        TestCase.assertTrue("NAN check failed", Double.isNaN(d.doubleValue()));
    }

    /**
     * java.lang.Double#longBitsToDouble(long)
     */
    public void test_longBitsToDoubleJ() {
        // Test for method double java.lang.Double.longBitsToDouble(long)
        Double d = new Double(Double.MAX_VALUE);
        long lbits = Double.doubleToLongBits(d.doubleValue());
        double r = Double.longBitsToDouble(lbits);
        TestCase.assertTrue("Bit conversion failed", ((d.doubleValue()) == r));
    }

    /**
     * java.lang.Double#longValue()
     */
    public void test_longValue() {
        // Test for method long java.lang.Double.longValue()
        Double d = new Double(1923311.47712);
        TestCase.assertEquals("Returned incorrect long value", 1923311, d.longValue());
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDoubleLjava_lang_String() {
        if (System.getProperty("os.arch").equals("armv7")) {
            return;
        }
        TestCase.assertEquals("Incorrect double returned, expected zero.", 0.0, Double.parseDouble("2.4703282292062327208828439643411e-324"), 0.0);
        TestCase.assertTrue("Incorrect double returned, expected minimum double.", ((Double.parseDouble("2.4703282292062327208828439643412e-324")) == (Double.MIN_VALUE)));
        for (int i = 324; i > 0; i--) {
            Double.parseDouble(("3.4e-" + i));
        }
        for (int i = 0; i <= 309; i++) {
            Double.parseDouble(("1.2e" + i));
        }
        /* The first two cases and the last four cases have to placed outside
        the loop due to the difference in the expected output string.
         */
        doTestCompareRawBits("3.4e-324", DoubleTest.rawBitsFor3_4en324ToN1[0], "4.9e-324");
        doTestCompareRawBits("3.4e-323", DoubleTest.rawBitsFor3_4en324ToN1[1], "3.5e-323");
        for (int i = 322; i > 3; i--) {
            String testString;
            String expectedString;
            testString = expectedString = "3.4e-" + i;
            doTestCompareRawBits(testString, DoubleTest.rawBitsFor3_4en324ToN1[(324 - i)], expectedString);
        }
        doTestCompareRawBits("3.4e-3", DoubleTest.rawBitsFor3_4en324ToN1[321], "0.0034");
        doTestCompareRawBits("3.4e-2", DoubleTest.rawBitsFor3_4en324ToN1[322], "0.034");
        doTestCompareRawBits("3.4e-1", DoubleTest.rawBitsFor3_4en324ToN1[323], "0.34");
        doTestCompareRawBits("3.4e-0", DoubleTest.rawBitsFor3_4en324ToN1[324], "3.4");
        doTestCompareRawBits("1.2e0", DoubleTest.rawBitsFor1_2e0To309[0], "1.2");
        doTestCompareRawBits("1.2e1", DoubleTest.rawBitsFor1_2e0To309[1], "12.0");
        doTestCompareRawBits("1.2e2", DoubleTest.rawBitsFor1_2e0To309[2], "120.0");
        doTestCompareRawBits("1.2e3", DoubleTest.rawBitsFor1_2e0To309[3], "1200.0");
        doTestCompareRawBits("1.2e4", DoubleTest.rawBitsFor1_2e0To309[4], "12000.0");
        doTestCompareRawBits("1.2e5", DoubleTest.rawBitsFor1_2e0To309[5], "120000.0");
        doTestCompareRawBits("1.2e6", DoubleTest.rawBitsFor1_2e0To309[6], "1200000.0");
        for (int i = 7; i <= 308; i++) {
            String testString;
            String expectedString;
            testString = expectedString = "1.2e" + i;
            doTestCompareRawBits(testString, DoubleTest.rawBitsFor1_2e0To309[i], expectedString);
        }
        doTestCompareRawBits("1.2e309", DoubleTest.rawBitsFor1_2e0To309[309], "Infinity");
        doTestCompareRawBits("111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000.92233720368547758079223372036854775807", 9080736897773724735L, "1.1122233344455567E299");
        doTestCompareRawBits("-111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000111222333444555666777888999000.92233720368547758079223372036854775807", -142635139081051073L, "-1.1122233344455567E299");
        doTestCompareRawBits("1.234123412431233E107", 6209029720863344363L, "1.234123412431233E107");
        doTestCompareRawBits("1.2341234124312331E107", 6209029720863344364L, "1.2341234124312331E107");
        doTestCompareRawBits("1.2341234124312332E107", 6209029720863344364L, "1.2341234124312331E107");
        doTestCompareRawBits("-1.234123412431233E107", -3014342315991431445L, "-1.234123412431233E107");
        doTestCompareRawBits("-1.2341234124312331E107", -3014342315991431444L, "-1.2341234124312331E107");
        doTestCompareRawBits("-1.2341234124312332E107", -3014342315991431444L, "-1.2341234124312331E107");
        // Java spec requires Double.toString to have exponent corresponding to the
        // binary value, in this case is 22, since the binary value is very slightly
        // less than 10^23. Therefore the correct decimal representation is
        // 9.999999999999999e22.
        // See ag/831934
        doTestCompareRawBits("1e23", 4950912855330343670L, "9.999999999999999e22");
        doTestCompareRawBits("1e22", 4936209963552724370L, "1.0e22");
        /* These particular tests verify that the extreme boundary conditions
        are converted correctly.
         */
        doTestCompareRawBits("0.0e-309", 0L, "0.0");
        doTestCompareRawBits("-0.0e-309", -9223372036854775808L, "-0.0");
        doTestCompareRawBits("0.0e309", 0L, "0.0");
        doTestCompareRawBits("-0.0e309", -9223372036854775808L, "-0.0");
        doTestCompareRawBits("0.1e309", 9214871658872686752L, "1.0e308");
        doTestCompareRawBits("0.2e309", 9218868437227405312L, "Infinity");
        doTestCompareRawBits("65e-325", 1L, "4.9e-324");
        doTestCompareRawBits("1000e-326", 2L, "1.0e-323");
        doTestCompareRawBits("4.0e-306", 37850267807446929L, "4.0e-306");
        doTestCompareRawBits("2.22507e-308", 4503591817664976L, "2.22507e-308");
        doTestCompareRawBits("111222333444555666777888999000111228999000.92233720368547758079223372036854775807", 5220918428364299659L, "1.1122233344455567E41");
        doTestCompareRawBits("-111222333444555666777888999000111228999000.92233720368547758079223372036854775807", -4002453608490476149L, "-1.1122233344455567E41");
        doTestCompareRawBits("1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890.987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210", 6089447104027554921L, "1.2345678901234567E99");
        doTestCompareRawBits("-1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890.987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210987654321098765432109876543210", -3133924932827220887L, "-1.2345678901234567E99");
        doTestCompareRawBits("179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.01", 9218868437227405311L, "1.7976931348623157E308");
        doTestCompareRawBits("-179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.01", -4503599627370497L, "-1.7976931348623157E308");
        doTestCompareRawBits("1112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001234567890", 9218868437227405312L, "Infinity");
        doTestCompareRawBits("-1112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001112223334445556667778889990001234567890", -4503599627370496L, "-Infinity");
        doTestCompareRawBits("179769313486231590000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.01", 9218868437227405312L, "Infinity");
        doTestCompareRawBits("-179769313486231590000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.01", -4503599627370496L, "-Infinity");
        doTestCompareRawBits("0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", 3114567014489548318L, "1.7976931348623157E-100");
        doTestCompareRawBits("-0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", -6108805022365227490L, "-1.7976931348623157E-100");
        doTestCompareRawBits("0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", 122515484224949857L, "1.7976931348623157E-300");
        doTestCompareRawBits("-0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", -9100856552629825951L, "-1.7976931348623157E-300");
        doTestCompareRawBits("0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", 36385714125122L, "1.79769313486234E-310");
        doTestCompareRawBits("-0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", -9223335651140650686L, "-1.79769313486234E-310");
        doTestCompareRawBits("0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", 3639L, "1.798E-320");
        doTestCompareRawBits("-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017976931348623157", -9223372036854772169L, "-1.798E-320");
        doTestCompareRawBits("0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001", 2L, "1.0E-323");
        doTestCompareRawBits("-0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001", -9223372036854775806L, "-1.0E-323");
        doTestCompareRawBits("0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055595409854908458349204328908234982349050934129878452378432452458968024357823490509341298784523784324524589680243578234905093412987845237843245245896802435782349050934129878452378432452458968024357868024357823490509341298784523784324524589680243578234905093412987845237843245245896802435786802435782349050934129878452378432452458968024357823490509341298784523784324524589680243578", 1L, "4.9E-324");
        doTestCompareRawBits("-0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055595409854908458349204328908234982349050934129878452378432452458968024357823490509341298784523784324524589680243578234905093412987845237843245245896802435782349050934129878452378432452458968024357868024357823490509341298784523784324524589680243578234905093412987845237843245245896802435786802435782349050934129878452378432452458968024357823490509341298784523784324524589680243578", -9223372036854775807L, "-4.9E-324");
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_Illegal() {
        try {
            Double.parseDouble("0.0p0D");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble("+0x.p1d");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble("0Xg.gp1D");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble("-0x1.1p");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble("+0x 1.1 p2d");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble("x1.1p2d");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble(" 0x-2.1p2");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble(" 0x2.1pad");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
        try {
            Double.parseDouble(" 0x111.222p 22d");
            TestCase.fail("Should throw NumberFormatException.");
        } catch (NumberFormatException e) {
            // expected
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_FromHexString() {
        double actual;
        double expected;
        actual = Double.parseDouble("0x0.0p0D");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0xa.ap+9d");
        TestCase.assertEquals("Returned incorrect value", 5440.0, actual, 0.0);
        actual = Double.parseDouble("+0Xb.10ap8");
        TestCase.assertEquals("Returned incorrect value", 2832.625, actual, 0.0);
        actual = Double.parseDouble("-0X.a0P2D");
        TestCase.assertEquals("Returned incorrect value", (-2.5), actual, 0.0);
        actual = Double.parseDouble("\r 0x22.1p2d \t");
        TestCase.assertEquals("Returned incorrect value", 136.25, actual, 0.0);
        actual = Double.parseDouble("0x1.0p-1");
        TestCase.assertEquals("Returned incorrect value", 0.5, actual, 0.0);
        actual = Double.parseDouble("0x00000000000000000000000000000000001.0p-1");
        TestCase.assertEquals("Returned incorrect value", 0.5, actual, 0.0);
        actual = Double.parseDouble("0x1.0p-00000000000000000000000000001");
        TestCase.assertEquals("Returned incorrect value", 0.5, actual, 0.0);
        actual = Double.parseDouble("0x.100000000000000000000000000000000p1");
        TestCase.assertEquals("Returned incorrect value", 0.125, actual, 0.0);
        actual = Double.parseDouble("0x0.0p999999999999999999999999999999999999999999999999999999999999999");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0xf1.0p9999999999999999999999999999999999999999999999999999999999999999");
        TestCase.assertEquals("Returned incorrect value", Double.POSITIVE_INFINITY, actual, 0.0);
        actual = Double.parseDouble("0xffffffffffffffffffffffffffffffffffff.ffffffffffffffffffffffffffffffffffffffffffffffp1");
        expected = Double.longBitsToDouble(5260204364768739328L);
        TestCase.assertEquals("Returned incorrect value", expected, actual, 0.0);
        actual = Double.parseDouble("0x0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001p1600");
        expected = Double.longBitsToDouble(9164825241698959360L);
        TestCase.assertEquals("Returned incorrect value", expected, actual, 0.0);
        actual = Double.parseDouble("0x0.0p-999999999999999999999999999999999999999999999999999999");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0xf1.0p-9999999999999999999999999999999999999999999999999999999999999999");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000p-1600");
        expected = Double.longBitsToDouble(67553994410557440L);
        TestCase.assertEquals("Returned incorrect value", expected, actual, 0.0);
        actual = Double.parseDouble("0x1.p9223372036854775807");
        TestCase.assertEquals("Returned incorrect value", Double.POSITIVE_INFINITY, actual, 0.0);
        actual = Double.parseDouble("0x1.p9223372036854775808");
        TestCase.assertEquals("Returned incorrect value", Double.POSITIVE_INFINITY, actual, 0.0);
        actual = Double.parseDouble("0x10.p9223372036854775808");
        TestCase.assertEquals("Returned incorrect value", Double.POSITIVE_INFINITY, actual, 0.0);
        actual = Double.parseDouble("0xabcd.ffffffffp+2000");
        TestCase.assertEquals("Returned incorrect value", Double.POSITIVE_INFINITY, actual, 0.0);
        actual = Double.parseDouble("0x1.p-9223372036854775808");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0x1.p-9223372036854775809");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0x.1p-9223372036854775809");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
        actual = Double.parseDouble("0xabcd.ffffffffffffffp-2000");
        TestCase.assertEquals("Returned incorrect value", 0.0, actual, 0.0);
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_NormalPositiveExponent() {
        long[] expecteds = new long[]{ 4553759719220231391L, 4675036584771676042L, 4729079777856762821L, 4781021256908714949L, 4832662568064604642L, 4883403105541118434L, 4934143643017632226L, 4984884180494146018L, 5035324550685437169L, 5085464617374231793L, 5138889818056639848L, 5188728554134914408L, 5238567290213188968L, 5288406026291463528L, 5338244762369738088L, 5388083498448012648L, 5437922234526287208L, 5487760970604561768L, 5537599706682836328L, 5589047421252510388L, 5638789376685220532L, 5688478542674895540L, 5738167708664570548L, 5787856874654245556L, 5837546040643920564L, 5887235206633595572L, 5936924372623270580L, 5986613538612945588L, 6037147335691182772L, 6086836501680857780L, 6136578457113567924L, 6186267623103242932L, 6235956789092917940L, 6285645955082592948L, 6335335121072267956L, 6385024287061942964L, 6434713453051617972L, 6485215356771684698L, 6534829737717059930L, 6584444118662435162L, 6634084894329327962L, 6683699275274703194L, 6733313656220078426L, 6782928037165453658L, 6832542418110828890L, 6882156799056204122L, 6932193495545860442L, 6981807876491235674L, 7031422257436610906L, 7081036638381986138L, 7130677414048878938L, 7180291794994254170L, 7229906175939629402L, 7279520556885004634L, 7329134937830379866L, 7379171634320036186L, 7428786015265411418L, 7478400396210786650L, 7528014777156161882L, 7577629158101537114L, 7627269933768429914L, 7676884314713805146L, 7726498695659180378L, 7776113076604555610L, 7826149773094211930L, 7875764154039587162L, 7925378534984962394L, 7974992915930337626L, 8024607296875712858L, 8074221677821088090L, 8123862453487980890L, 8173476834433356122L, 8223091215378731354L, 8273120213673994413L, 8322697202097219757L, 8372274190520445101L, 8421851178943670445L, 8471428167366895789L, 8521005155790121133L, 8570582144213346477L, 8620172329997330605L, 8669749318420555949L, 8719537464615921837L, 8769114453039147181L, 8818691441462372525L, 8868268429885597869L, 8917845418308823213L, 8967422406732048557L, 9016999395155273901L, 9066576383578499245L, 9116166569362483373L, 9169330009574286149L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L };
        for (int i = 0; i < (expecteds.length); i++) {
            int part = i * 11;
            String inputString = (((("0x" + part) + ".") + part) + "0123456789abcdefp") + part;
            double actual = Double.parseDouble(inputString);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + inputString) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_NormalNegativeExponent() {
        long[] expecteds = new long[]{ 4553759719220231391L, 4575957392969525130L, 4530921394252460997L, 4483783681502262213L, 4436345800856000994L, 4388007146530363874L, 4339668492204726754L, 4291329837879089634L, 4242691016268229873L, 4193751891154873585L, 4148097900035130728L, 4098857444311254376L, 4049616988587378024L, 4000376532863501672L, 3951136077139625320L, 3901895621415748968L, 3852655165691872616L, 3803414709967996264L, 3754174254244119912L, 3706542777011643060L, 3657205540642202292L, 3607815514829726388L, 3558425489017250484L, 3509035463204774580L, 3459645437392298676L, 3410255411579822772L, 3360865385767346868L, 3311475359954870964L, 3262929965230957236L, 3213539939418481332L, 3164202703049040564L, 3114812677236564660L, 3065422651424088756L, 3016032625611612852L, 2966642599799136948L, 2917252573986661044L, 2867862548174185140L, 2819285260092100954L, 2769820449235325274L, 2720355638378549594L, 2670917222243291482L, 2621452411386515802L, 2571987600529740122L, 2522522789672964442L, 2473057978816188762L, 2423593167959413082L, 2374550672646918490L, 2325085861790142810L, 2275621050933367130L, 2226156240076591450L, 2176717823941333338L, 2127253013084557658L, 2077788202227781978L, 2028323391371006298L, 1978858580514230618L, 1929816085201736026L, 1880351274344960346L, 1830886463488184666L, 1781421652631408986L, 1731956841774633306L, 1682518425639375194L, 1633053614782599514L, 1583588803925823834L, 1534123993069048154L, 1485081497756553562L, 1435616686899777882L, 1386151876043002202L, 1336687065186226522L, 1287222254329450842L, 1237757443472675162L, 1188319027337417050L, 1138854216480641370L, 1089389405623865690L, 1040339212116977837L, 990837008738052269L, 941334805359126701L, 891832601980201133L, 842330398601275565L, 792828195222349997L, 743325991843424429L, 693836985825257645L, 644334782446332077L, 595043736839547053L, 545541533460621485L, 496039330081695917L, 446537126702770349L, 397034923323844781L, 347532719944919213L, 298030516565993645L, 248528313187068077L, 199039307168901293L, 153123555578553157L, 103602651660362565L, 54081747742171973L, 4560843823981381L, 2236101468196L, 1096302936L, 537480L, 264L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L };
        for (int i = 0; i < (expecteds.length); i++) {
            int part = i * 11;
            String inputString = (((("0x" + part) + ".") + part) + "0123456789abcdefp-") + part;
            double actual = Double.parseDouble(inputString);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + inputString) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_MaxNormalBoundary() {
        long[] expecteds = new long[]{ 9218868437227405311L, 9218868437227405311L, 9218868437227405311L, 9218868437227405311L, 9218868437227405311L, 9218868437227405311L, 9218868437227405311L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, 9218868437227405312L, -4503599627370497L, -4503599627370497L, -4503599627370497L, -4503599627370497L, -4503599627370497L, -4503599627370497L, -4503599627370497L, -4503599627370496L, -4503599627370496L, -4503599627370496L, -4503599627370496L, -4503599627370496L, -4503599627370496L, -4503599627370496L, -4503599627370496L };
        String[] inputs = new String[]{ "0x1.fffffffffffffp1023", "0x1.fffffffffffff000000000000000000000000001p1023", "0x1.fffffffffffff1p1023", "0x1.fffffffffffff100000000000000000000000001p1023", "0x1.fffffffffffff1fffffffffffffffffffffffffffffffffffffffffffffp1023", "0x1.fffffffffffff7p1023", "0x1.fffffffffffff700000000000000000000000001p1023", "0x1.fffffffffffff8p1023", "0x1.fffffffffffff800000000000000000000000001p1023", "0x1.fffffffffffff8fffffffffffffffffffffffffffffffffffffffffffffp1023", "0x1.fffffffffffff9p1023", "0x1.fffffffffffff900000000000000000000000001p1023", "0x1.ffffffffffffffp1023", "0x1.ffffffffffffff00000000000000000000000001p1023", "0x1.fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp1023", "-0x1.fffffffffffffp1023", "-0x1.fffffffffffff000000000000000000000000001p1023", "-0x1.fffffffffffff1p1023", "-0x1.fffffffffffff100000000000000000000000001p1023", "-0x1.fffffffffffff1fffffffffffffffffffffffffffffffffffffffffffffp1023", "-0x1.fffffffffffff7p1023", "-0x1.fffffffffffff700000000000000000000000001p1023", "-0x1.fffffffffffff8p1023", "-0x1.fffffffffffff800000000000000000000000001p1023", "-0x1.fffffffffffff8fffffffffffffffffffffffffffffffffffffffffffffp1023", "-0x1.fffffffffffff9p1023", "-0x1.fffffffffffff900000000000000000000000001p1023", "-0x1.ffffffffffffffp1023", "-0x1.ffffffffffffff00000000000000000000000001p1023", "-0x1.fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp1023" };
        for (int i = 0; i < (inputs.length); i++) {
            double actual = Double.parseDouble(inputs[i]);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + (inputs[i])) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_MinNormalBoundary() {
        long[] expecteds = new long[]{ 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370497L, 4503599627370497L, 4503599627370497L, 4503599627370497L, 4503599627370497L, 4503599627370497L, 4503599627370497L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405311L, -9218868437227405311L, -9218868437227405311L, -9218868437227405311L, -9218868437227405311L, -9218868437227405311L, -9218868437227405311L };
        String[] inputs = new String[]{ "0x1.0p-1022", "0x1.00000000000001p-1022", "0x1.000000000000010000000000000000001p-1022", "0x1.00000000000001fffffffffffffffffffffffffffffffffp-1022", "0x1.00000000000007p-1022", "0x1.000000000000070000000000000000001p-1022", "0x1.00000000000007fffffffffffffffffffffffffffffffffp-1022", "0x1.00000000000008p-1022", "0x1.000000000000080000000000000000001p-1022", "0x1.00000000000008fffffffffffffffffffffffffffffffffp-1022", "0x1.00000000000009p-1022", "0x1.000000000000090000000000000000001p-1022", "0x1.00000000000009fffffffffffffffffffffffffffffffffp-1022", "0x1.0000000000000fp-1022", "0x1.0000000000000ffffffffffffffffffffffffffffffffffp-1022", "-0x1.0p-1022", "-0x1.00000000000001p-1022", "-0x1.000000000000010000000000000000001p-1022", "-0x1.00000000000001fffffffffffffffffffffffffffffffffp-1022", "-0x1.00000000000007p-1022", "-0x1.000000000000070000000000000000001p-1022", "-0x1.00000000000007fffffffffffffffffffffffffffffffffp-1022", "-0x1.00000000000008p-1022", "-0x1.000000000000080000000000000000001p-1022", "-0x1.00000000000008fffffffffffffffffffffffffffffffffp-1022", "-0x1.00000000000009p-1022", "-0x1.000000000000090000000000000000001p-1022", "-0x1.00000000000009fffffffffffffffffffffffffffffffffp-1022", "-0x1.0000000000000fp-1022", "-0x1.0000000000000ffffffffffffffffffffffffffffffffffp-1022" };
        for (int i = 0; i < (inputs.length); i++) {
            double actual = Double.parseDouble(inputs[i]);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + (inputs[i])) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_MaxSubNormalBoundary() {
        long[] expecteds = new long[]{ 4503599627370495L, 4503599627370495L, 4503599627370495L, 4503599627370495L, 4503599627370495L, 4503599627370495L, 4503599627370495L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, 4503599627370496L, -9218868437227405313L, -9218868437227405313L, -9218868437227405313L, -9218868437227405313L, -9218868437227405313L, -9218868437227405313L, -9218868437227405313L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L, -9218868437227405312L };
        String[] inputs = new String[]{ "0x0.fffffffffffffp-1022", "0x0.fffffffffffff00000000000000000000000000000000001p-1022", "0x0.fffffffffffff1p-1022", "0x0.fffffffffffff10000000000000000000000000000000001p-1022", "0x0.fffffffffffff1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "0x0.fffffffffffff7p-1022", "0x0.fffffffffffff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "0x0.fffffffffffff8p-1022", "0x0.fffffffffffff80000000000000000000000000000000001p-1022", "0x0.fffffffffffff8ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "0x0.fffffffffffff9p-1022", "0x0.fffffffffffff9ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "0x0.ffffffffffffffp-1022", "0x0.ffffffffffffff0000000000000000000000000000000001p-1022", "0x0.ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "-0x0.fffffffffffffp-1022", "-0x0.fffffffffffff00000000000000000000000000000000001p-1022", "-0x0.fffffffffffff1p-1022", "-0x0.fffffffffffff10000000000000000000000000000000001p-1022", "-0x0.fffffffffffff1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "-0x0.fffffffffffff7p-1022", "-0x0.fffffffffffff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "-0x0.fffffffffffff8p-1022", "-0x0.fffffffffffff80000000000000000000000000000000001p-1022", "-0x0.fffffffffffff8ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "-0x0.fffffffffffff9p-1022", "-0x0.fffffffffffff9ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022", "-0x0.ffffffffffffffp-1022", "-0x0.ffffffffffffff0000000000000000000000000000000001p-1022", "-0x0.ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffp-1022" };
        for (int i = 0; i < (inputs.length); i++) {
            double actual = Double.parseDouble(inputs[i]);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + (inputs[i])) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_MinSubNormalBoundary() {
        long[] expecteds = new long[]{ 1L, 1L, 2L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, -9223372036854775807L, -9223372036854775807L, -9223372036854775806L, -9223372036854775807L, -9223372036854775807L, -9223372036854775807L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L, -9223372036854775806L };
        String[] inputs = new String[]{ "0x0.0000000000001p-1022", "0x0.00000000000010000000000000000001p-1022", "0x0.0000000000001fffffffffffffffffffffffffffffffffp-1022", "0x0.00000000000017p-1022", "0x0.000000000000170000000000000000001p-1022", "0x0.00000000000017fffffffffffffffffffffffffffffffffp-1022", "0x0.00000000000018p-1022", "0x0.000000000000180000000000000000001p-1022", "0x0.00000000000018fffffffffffffffffffffffffffffffffp-1022", "0x0.00000000000019p-1022", "0x0.000000000000190000000000000000001p-1022", "0x0.00000000000019fffffffffffffffffffffffffffffffffp-1022", "0x0.0000000000001fp-1022", "0x0.0000000000001f0000000000000000001p-1022", "0x0.0000000000001ffffffffffffffffffffffffffffffffffp-1022", "-0x0.0000000000001p-1022", "-0x0.00000000000010000000000000000001p-1022", "-0x0.0000000000001fffffffffffffffffffffffffffffffffp-1022", "-0x0.00000000000017p-1022", "-0x0.000000000000170000000000000000001p-1022", "-0x0.00000000000017fffffffffffffffffffffffffffffffffp-1022", "-0x0.00000000000018p-1022", "-0x0.000000000000180000000000000000001p-1022", "-0x0.00000000000018fffffffffffffffffffffffffffffffffp-1022", "-0x0.00000000000019p-1022", "-0x0.000000000000190000000000000000001p-1022", "-0x0.00000000000019fffffffffffffffffffffffffffffffffp-1022", "-0x0.0000000000001fp-1022", "-0x0.0000000000001f0000000000000000001p-1022", "-0x0.0000000000001ffffffffffffffffffffffffffffffffffp-1022" };
        for (int i = 0; i < (inputs.length); i++) {
            double actual = Double.parseDouble(inputs[i]);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + (inputs[i])) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#parseDouble(java.lang.String)
     */
    public void test_parseDouble_LString_ZeroBoundary() {
        long[] expecteds = new long[]{ 0L, 0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, -9223372036854775808L, -9223372036854775808L, -9223372036854775808L, -9223372036854775807L, -9223372036854775807L, -9223372036854775807L, -9223372036854775807L, -9223372036854775807L, -9223372036854775807L };
        String[] inputs = new String[]{ "0x0.00000000000004p-1022", "0x0.00000000000007ffffffffffffffffffffffp-1022", "0x0.00000000000008p-1022", "0x0.000000000000080000000000000000001p-1022", "0x0.00000000000008fffffffffffffffffffffffffffffffp-1022", "0x0.00000000000009p-1022", "0x0.000000000000090000000000000000001p-1022", "0x0.00000000000009fffffffffffffffffffffffffffffffffp-1022", "0x0.0000000000000fffffffffffffffffffffffffffffffffffp-1022", "-0x0.00000000000004p-1022", "-0x0.00000000000007ffffffffffffffffffffffp-1022", "-0x0.00000000000008p-1022", "-0x0.000000000000080000000000000000001p-1022", "-0x0.00000000000008fffffffffffffffffffffffffffffffp-1022", "-0x0.00000000000009p-1022", "-0x0.000000000000090000000000000000001p-1022", "-0x0.00000000000009fffffffffffffffffffffffffffffffffp-1022", "-0x0.0000000000000fffffffffffffffffffffffffffffffffffp-1022" };
        for (int i = 0; i < (inputs.length); i++) {
            double actual = Double.parseDouble(inputs[i]);
            double expected = Double.longBitsToDouble(expecteds[i]);
            String expectedString = "0x" + (Long.toHexString(Double.doubleToLongBits(expected)));
            String actualString = "0x" + (Long.toHexString(Double.doubleToLongBits(actual)));
            String errorMsg = ((((((i + "th input string is:<") + (inputs[i])) + ">.The expected result should be:<") + expectedString) + ">, but was: <") + actualString) + ">. ";
            TestCase.assertEquals(errorMsg, expected, actual, 0.0);
        }
    }

    /**
     * java.lang.Double#shortValue()
     */
    public void test_shortValue() {
        // Test for method short java.lang.Double.shortValue()
        Double d = new Double(1923311.47712);
        TestCase.assertEquals("Returned incorrect short value", 22767, d.shortValue());
    }

    /**
     * java.lang.Double#toString()
     */
    public void test_toString() {
        // Test for method java.lang.String java.lang.Double.toString()
        test_toString(1.7976931348623157E308, "1.7976931348623157E308");
        test_toString(5.0E-4, "5.0E-4");
    }

    /**
     * java.lang.Double#toString(double)
     */
    public void test_toStringD() {
        // Test for method java.lang.String java.lang.Double.toString(double)
        test_toString(1.7976931348623157E308, "1.7976931348623157E308");
        test_toString((1.0 / 0.0), "Infinity");
        test_toString((0.0 / 0.0), "NaN");
        test_toString(((-1.0) / 0.0), "-Infinity");
        double d;
        d = Double.longBitsToDouble(5120592776320253951L);
        test_toString(d, "2.0769187434139308E34");
        d = Double.longBitsToDouble(5120592776320253952L);
        test_toString(d, "2.076918743413931E34");
        d = Double.longBitsToDouble(5116089176692883466L);
        test_toString(d, "1.0384593717069678E34");
        d = Double.longBitsToDouble(5116089176692883467L);
        test_toString(d, "1.038459371706968E34");
        d = Double.longBitsToDouble(5116089176692883479L);
        test_toString(d, "1.0384593717069708E34");
        d = Double.longBitsToDouble(5116089176692883480L);
        test_toString(d, "1.038459371706971E34");
        d = Double.longBitsToDouble(5116089176692883492L);
        test_toString(d, "1.0384593717069738E34");
        d = Double.longBitsToDouble(5116089176692883493L);
        test_toString(d, "1.038459371706974E34");
        d = Double.longBitsToDouble(5116089176692883505L);
        test_toString(d, "1.0384593717069768E34");
        d = Double.longBitsToDouble(5116089176692883506L);
        test_toString(d, "1.038459371706977E34");
        d = Double.longBitsToDouble(5116089176692883518L);
        test_toString(d, "1.0384593717069798E34");
        d = Double.longBitsToDouble(5116089176692883519L);
        test_toString(d, "1.03845937170698E34");
        d = Double.longBitsToDouble(9079256848778919939L);
        test_toString(d, "8.371160993642719E298");
        d = Double.longBitsToDouble(9079256848778919940L);
        test_toString(d, "8.37116099364272E298");
        d = Double.longBitsToDouble(9079256848778919944L);
        test_toString(d, "8.371160993642728E298");
        d = Double.longBitsToDouble(9079256848778919945L);
        test_toString(d, "8.37116099364273E298");
        d = Double.longBitsToDouble(9079256848778919955L);
        test_toString(d, "8.371160993642749E298");
        d = Double.longBitsToDouble(9079256848778919956L);
        test_toString(d, "8.37116099364275E298");
        d = Double.longBitsToDouble(9079256848778919971L);
        test_toString(d, "8.371160993642779E298");
        d = Double.longBitsToDouble(9079256848778919972L);
        test_toString(d, "8.37116099364278E298");
        d = Double.longBitsToDouble(9079256848778919982L);
        test_toString(d, "8.371160993642799E298");
        d = Double.longBitsToDouble(9079256848778919983L);
        test_toString(d, "8.3711609936428E298");
        d = Double.longBitsToDouble(-2738188573441261567L);
        test_toString(d, "-3.3846065602060736E125");
        d = Double.longBitsToDouble(-2738188573441261566L);
        test_toString(d, "-3.384606560206074E125");
        d = Double.longBitsToDouble(-2738188573441261563L);
        test_toString(d, "-3.3846065602060766E125");
        d = Double.longBitsToDouble(-2738188573441261562L);
        test_toString(d, "-3.384606560206077E125");
        d = Double.longBitsToDouble(-2738188573441261559L);
        test_toString(d, "-3.3846065602060796E125");
        d = Double.longBitsToDouble(-2738188573441261558L);
        test_toString(d, "-3.38460656020608E125");
        d = Double.longBitsToDouble(-2738188573441261555L);
        test_toString(d, "-3.3846065602060826E125");
        d = Double.longBitsToDouble(-2738188573441261554L);
        test_toString(d, "-3.384606560206083E125");
    }

    /**
     * java.lang.Double#valueOf(java.lang.String)
     */
    public void test_valueOfLjava_lang_String() {
        // Test for method java.lang.Double
        // java.lang.Double.valueOf(java.lang.String)
        TestCase.assertTrue("Incorrect double returned", ((Math.abs(((Double.valueOf("999999999999.999").doubleValue()) - 9.99999999999999E11))) < 1));
        try {
            Double.valueOf(null);
            TestCase.fail("Expected Double.valueOf(null) to throw NPE.");
        } catch (NullPointerException ex) {
            // expected
        }
        try {
            Double.valueOf("");
            TestCase.fail("Expected Double.valueOf(\"\") to throw NFE");
        } catch (NumberFormatException e) {
            // expected
        }
        Double pi = Double.valueOf("3.141592654");
        TestCase.assertEquals(3.141592654, pi.doubleValue(), 0.0);
        Double posZero = Double.valueOf("+0.0");
        Double negZero = Double.valueOf("-0.0");
        TestCase.assertFalse("Doubletest0", posZero.equals(negZero));
        // Tests for double values by name.
        Double expectedNaN = new Double(Double.NaN);
        Double posNaN = Double.valueOf("NaN");
        TestCase.assertTrue("Doubletest1", posNaN.equals(expectedNaN));
        Double posNaNSigned = Double.valueOf("+NaN");
        TestCase.assertTrue("Doubletest2", posNaNSigned.equals(expectedNaN));
        Double negNaNSigned = Double.valueOf("-NaN");
        TestCase.assertTrue("Doubletest3", negNaNSigned.equals(expectedNaN));
        Double posInfinite = Double.valueOf("Infinity");
        TestCase.assertTrue("Doubletest4", posInfinite.equals(new Double(Double.POSITIVE_INFINITY)));
        Double posInfiniteSigned = Double.valueOf("+Infinity");
        TestCase.assertTrue("Doubletest5", posInfiniteSigned.equals(new Double(Double.POSITIVE_INFINITY)));
        Double negInfiniteSigned = Double.valueOf("-Infinity");
        TestCase.assertTrue("Doubletest6", negInfiniteSigned.equals(new Double(Double.NEGATIVE_INFINITY)));
    }

    /**
     * java.lang.Double#compareTo(java.lang.Double)
     * java.lang.Double#compare(double, double)
     */
    public void test_compareToLjava_lang_Double() {
        if (System.getProperty("os.arch").equals("armv7")) {
            return;
        }
        // A selection of double values in ascending order.
        double[] values = new double[]{ Double.NEGATIVE_INFINITY, -(Double.MAX_VALUE), -2.0, -(Double.MIN_VALUE), -0.0, 0.0, Double.MIN_VALUE, 2.0, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN };
        for (int i = 0; i < (values.length); i++) {
            double d1 = values[i];
            // Test that each value compares equal to itself; and each object is
            // equal to another object like itself.
            TestCase.assertTrue(("Assert 0: compare() should be equal: " + d1), ((Double.compare(d1, d1)) == 0));
            Double objDouble = new Double(d1);
            TestCase.assertTrue(("Assert 1: compareTo() should be equal: " + d1), ((objDouble.compareTo(objDouble)) == 0));
            // Test that the Double-defined order is respected
            for (int j = i + 1; j < (values.length); j++) {
                double d2 = values[j];
                TestCase.assertTrue(((("Assert 2: compare() " + d1) + " should be less ") + d2), ((Double.compare(d1, d2)) == (-1)));
                TestCase.assertTrue(((("Assert 3: compare() " + d2) + " should be greater ") + d1), ((Double.compare(d2, d1)) == 1));
                Double D2 = new Double(d2);
                TestCase.assertTrue(((("Assert 4: compareTo() " + d1) + " should be less ") + d2), ((objDouble.compareTo(D2)) == (-1)));
                TestCase.assertTrue(((("Assert 5: compareTo() " + d2) + " should be greater ") + d1), ((D2.compareTo(objDouble)) == 1));
            }
        }
        try {
            new Double(0.0).compareTo(null);
            TestCase.fail("No NPE");
        } catch (NullPointerException e) {
        }
    }

    /**
     * java.lang.Double#equals(java.lang.Object)
     */
    public void test_equalsLjava_lang_Object() {
        Double d1 = new Double(8.765432112345E7);
        Double d2 = new Double(8.765432112345E7);
        Double d3 = new Double(2.0E-4F);
        TestCase.assertTrue("Assert 0: Equality test failed", ((d1.equals(d2)) && (!(d1.equals(d3)))));
        TestCase.assertTrue("Assert 2: NaN should not be == Nan", ((Double.NaN) != (Double.NaN)));
        TestCase.assertTrue("Assert 3: NaN should not be == Nan", new Double(Double.NaN).equals(new Double(Double.NaN)));
        TestCase.assertTrue("Assert 4: -0d should be == 0d", (0.0 == (-0.0)));
        TestCase.assertTrue("Assert 5: -0d should not be equals() 0d", (!(new Double(0.0).equals(new Double((-0.0))))));
        Double dmax = new Double(Double.MAX_VALUE);
        Double dmax1 = new Double(Double.MAX_VALUE);
        TestCase.assertTrue("Equality test failed", ((dmax.equals(dmax1)) && (!(dmax.equals(new Object())))));
    }

    /**
     * java.lang.Double#toHexString(double)
     */
    public void test_toHexStringF() {
        // the follow values come from the Double Javadoc/Spec
        TestCase.assertEquals("0x0.0p0", Double.toHexString(0.0));
        TestCase.assertEquals("-0x0.0p0", Double.toHexString((-0.0)));
        TestCase.assertEquals("0x1.0p0", Double.toHexString(1.0));
        TestCase.assertEquals("-0x1.0p0", Double.toHexString((-1.0)));
        TestCase.assertEquals("0x1.0p1", Double.toHexString(2.0));
        TestCase.assertEquals("0x1.8p1", Double.toHexString(3.0));
        TestCase.assertEquals("0x1.0p-1", Double.toHexString(0.5));
        TestCase.assertEquals("0x1.0p-2", Double.toHexString(0.25));
        TestCase.assertEquals("0x1.fffffffffffffp1023", Double.toHexString(Double.MAX_VALUE));
        TestCase.assertEquals("0x0.0000000000001p-1022", Double.toHexString(Double.MIN_VALUE));
        // test edge cases
        TestCase.assertEquals("NaN", Double.toHexString(Double.NaN));
        TestCase.assertEquals("-Infinity", Double.toHexString(Double.NEGATIVE_INFINITY));
        TestCase.assertEquals("Infinity", Double.toHexString(Double.POSITIVE_INFINITY));
        // test various numbers
        TestCase.assertEquals("-0x1.da8p6", Double.toHexString((-118.625)));
        TestCase.assertEquals("0x1.2957874cccccdp23", Double.toHexString(9743299.65));
        TestCase.assertEquals("0x1.2957874cccccdp23", Double.toHexString(9743299.65));
        TestCase.assertEquals("0x1.2957874cccf63p23", Double.toHexString(9743299.650001233));
        TestCase.assertEquals("0x1.700d1061d3333p33", Double.toHexString(1.234974329965E10));
        // test HARMONY-2132
        TestCase.assertEquals("0x1.01p10", Double.toHexString(1028.0));
    }

    /**
     * java.lang.Double#valueOf(double)
     */
    public void test_valueOfD() {
        TestCase.assertEquals(new Double(Double.MIN_VALUE), Double.valueOf(Double.MIN_VALUE));
        TestCase.assertEquals(new Double(Double.MAX_VALUE), Double.valueOf(Double.MAX_VALUE));
        TestCase.assertEquals(new Double(0), Double.valueOf(0));
        int s = -128;
        while (s < 128) {
            TestCase.assertEquals(new Double(s), Double.valueOf(s));
            TestCase.assertEquals(new Double((s + 0.1)), Double.valueOf((s + 0.1)));
            s++;
        } 
    }

    /**
     * {@link java.lang.Double#MAX_EXPONENT}
     *
     * @since 1.6
     */
    public void test_MAX_EXPONENT() {
        TestCase.assertTrue("Wrong value of java.lang.Double.MAX_EXPONENT", ((Double.MAX_EXPONENT) == 1023));
        TestCase.assertTrue("Wrong value of java.lang.Double.MAX_EXPONENT", ((Double.MAX_EXPONENT) == (Math.getExponent(Double.MAX_VALUE))));
    }

    /**
     * {@link java.lang.Double#MIN_EXPONENT}
     *
     * @since 1.6
     */
    public void test_MIN_EXPONENT() {
        TestCase.assertTrue("Wrong value of java.lang.Double.MIN_EXPONENT", ((Double.MIN_EXPONENT) == (-1022)));
        TestCase.assertTrue("Wrong value of java.lang.Double.MIN_EXPONENT", ((Double.MIN_EXPONENT) == (Math.getExponent(Double.MIN_NORMAL))));
    }

    /**
     * {@link java.lang.Double#MIN_NORMAL}
     *
     * @since 1.6
     */
    public void test_MIN_NORMAL() {
        TestCase.assertTrue("Wrong value of java.lang.Double.MIN_NORMAL", ((Double.MIN_NORMAL) == 2.2250738585072014E-308));
        TestCase.assertTrue("Wrong value of java.lang.Double.MIN_NORMAL", ((Double.MIN_NORMAL) == (Double.longBitsToDouble(4503599627370496L))));
        TestCase.assertTrue("Wrong value of java.lang.Double.MIN_NORMAL", ((Double.MIN_NORMAL) == 2.2250738585072014E-308));
    }
}

