/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;


import com.google.common.base.Joiner;
import com.google.common.collect.Iterables;
import com.google.testing.compile.JavaFileObjects;
import dagger.tests.integration.ProcessorTestUtils;
import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;


/**
 * Tests that the annotation processor(s) will properly handle the case where
 * code they are processing and depending on is generated by other processors
 * in the environment, and so the types they need may not exist yet.
 */
@RunWith(JUnit4.class)
public class GeneratedTypesNotReadyTest {
    private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", ("" + ("package myPackage;\n" + "public interface Foo {}\n")));

    private final JavaFileObject main = JavaFileObjects.forSourceString("Main", ("" + (((("import javax.inject.Inject;\n" + "import myPackage.Foo;\n") + "class Main {\n") + "  @Inject Foo f;\n") + "}\n")));

    @Test
    public void withstandsMissingTypeReferencedInInjects() {
        // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
        JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ("" + (((((((("import dagger.Module;\n" + "import dagger.Provides;\n") + "import myPackage.Foo;\n") + "@Module(injects = { Main.class, myPackage.FooImpl.class })\n") + "class FooModule {\n") + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n") + "    return impl;\n") + "  }\n") + "}\n")));
        assertAbout(javaSources()).that(Arrays.asList(foo, main, module)).processedWith(Iterables.concat(Arrays.asList(new GeneratedTypesNotReadyTest.FooImplGenerator()), ProcessorTestUtils.daggerProcessors())).compilesWithoutError();
    }

    @Test
    public void withstandsMissingTypeReferencedInsideModule() {
        JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ("" + (((((((("import dagger.Module;\n" + "import dagger.Provides;\n") + "import myPackage.Foo;\n") + "@Module(injects = { Main.class })\n") + "class FooModule {\n") + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n") + "    return impl;\n") + "  }\n") + "}\n")));
        assertAbout(javaSources()).that(Arrays.asList(foo, module, main)).processedWith(Iterables.concat(ProcessorTestUtils.daggerProcessors(), Arrays.asList(new GeneratedTypesNotReadyTest.FooImplGenerator()))).compilesWithoutError();
    }

    @Test
    public void withstandsMissingTypeReferencedByProvidesReturnType() {
        JavaFileObject main = JavaFileObjects.forSourceString("Main", ("" + ((("import javax.inject.Inject;\n" + "class Main {\n") + "  @Inject myPackage.FooImpl f;\n") + "}\n")));
        JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ("" + ((((((("import dagger.Module;\n" + "import dagger.Provides;\n") + "@Module(injects = { Main.class })\n") + "class FooModule {\n") + "  @Provides myPackage.FooImpl provideFoo() {\n") + "    return new myPackage.FooImpl();\n") + "  }\n") + "}\n")));
        assertAbout(javaSources()).that(Arrays.asList(foo, module, main)).processedWith(Iterables.concat(ProcessorTestUtils.daggerProcessors(), Arrays.asList(new GeneratedTypesNotReadyTest.FooImplGenerator()))).compilesWithoutError();
    }

    @Test
    public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
        JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join("import javax.inject.Inject;", "class Main {", "  @Inject myPackage.FooImpl2<String> f;", "}"));
        JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join("import dagger.Module;", "import dagger.Provides;", "@Module(injects = { Main.class })", "class FooModule {", "  @Provides myPackage.FooImpl2<String> provideFoo() {", "    return new myPackage.FooImpl2<String>();", "  }", "}"));
        assertAbout(javaSources()).that(Arrays.asList(foo, module, main)).processedWith(new GeneratedTypesNotReadyTest.FooImplGenerator()).compilesWithoutError();
        assertAbout(javaSources()).that(Arrays.asList(foo, module, main)).processedWith(Iterables.concat(ProcessorTestUtils.daggerProcessors(), Arrays.asList(new GeneratedTypesNotReadyTest.FooImplGenerator()))).failsToCompile().withErrorContaining("Could not find types required by provides methods for [FooModule]");
    }

    @Test
    public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
        JavaFileObject main = JavaFileObjects.forSourceString("Main", ("" + (((("import javax.inject.Inject;\n" + "import myPackage.FooImpl;\n") + "class Main {\n") + "  @Inject FooImpl f;\n") + "}\n")));
        JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ("" + (((("import dagger.Module;\n" + "import dagger.Provides;\n") + "@Module(injects = { Main.class })\n") + "class FooModule {\n") + "}\n")));
        assertAbout(javaSources()).that(Arrays.asList(foo, module, main)).processedWith(Iterables.concat(ProcessorTestUtils.daggerProcessors(), Arrays.asList(new GeneratedTypesNotReadyTest.FooImplGenerator()))).compilesWithoutError();
    }

    @Test
    public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
        JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ("" + (((((((("import dagger.Module;\n" + "import dagger.Provides;\n") + "import myPackage.Foo;\n") + "@Module(injects = { Main.class })\n") + "class FooModule {\n") + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n") + "    return impl;\n") + "  }\n") + "}\n")));
        assertAbout(javaSources()).that(Arrays.asList(foo, module, main)).processedWith(new GeneratedTypesNotReadyTest.FooImplGenerator()).compilesWithoutError();
    }

    @SupportedAnnotationTypes("*")
    private final class FooImplGenerator extends AbstractProcessor {
        boolean written = false;

        @Override
        public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
            if (!(written)) {
                try {
                    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
                    Writer writer = sourceFile.openWriter();
                    writer.write(("" + (((("package myPackage;\n" + "import javax.inject.Inject;\n") + "public final class FooImpl implements Foo {\n") + "  @Inject public FooImpl() { }\n") + "}\n")));
                    writer.close();
                    sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
                    writer = sourceFile.openWriter();
                    writer.write(("" + (((("package myPackage;\n" + "import javax.inject.Inject;\n") + "public final class FooImpl2<T> implements Foo {\n") + "  @Inject public FooImpl2() { }\n") + "}\n")));
                    writer.close();
                    written = true;
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return false;
        }

        @Override
        public SourceVersion getSupportedSourceVersion() {
            return SourceVersion.latestSupported();
        }
    }
}

