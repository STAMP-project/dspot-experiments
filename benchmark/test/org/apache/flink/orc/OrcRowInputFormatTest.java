/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.flink.orc;


import PredicateLeaf.Type;
import Reader.Options;
import Types.INT;
import Types.STRING;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeinfo.Types;
import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;
import org.apache.flink.api.java.typeutils.RowTypeInfo;
import org.apache.flink.core.fs.FileInputSplit;
import org.apache.flink.core.fs.Path;
import org.apache.flink.types.Row;
import org.apache.flink.util.InstantiationUtil;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;
import org.apache.hadoop.hive.ql.io.sarg.SearchArgument;
import org.apache.orc.Reader;
import org.apache.orc.StripeInformation;
import org.junit.Assert;
import org.junit.Test;
import org.mockito.ArgumentMatchers;
import org.mockito.Mockito;


/**
 * Unit tests for {@link OrcRowInputFormat}.
 */
public class OrcRowInputFormatTest {
    private OrcRowInputFormat rowOrcInputFormat;

    private static final String TEST_FILE_FLAT = "test-data-flat.orc";

    private static final String TEST_SCHEMA_FLAT = "struct<_col0:int,_col1:string,_col2:string,_col3:string,_col4:int,_col5:string,_col6:int,_col7:int,_col8:int>";

    private static final String TEST_FILE_NESTED = "test-data-nested.orc";

    private static final String TEST_SCHEMA_NESTED = "struct<" + (((((((((((((((((((((((((((((("boolean1:boolean," + "byte1:tinyint,") + "short1:smallint,") + "int1:int,") + "long1:bigint,") + "float1:float,") + "double1:double,") + "bytes1:binary,") + "string1:string,") + "middle:struct<") + "list:array<") + "struct<") + "int1:int,") + "string1:string") + ">") + ">") + ">,") + "list:array<") + "struct<") + "int1:int,") + "string1:string") + ">") + ">,") + "map:map<") + "string,") + "struct<") + "int1:int,") + "string1:string") + ">") + ">") + ">");

    private static final String TEST_FILE_TIMETYPES = "test-data-timetypes.orc";

    private static final String TEST_SCHEMA_TIMETYPES = "struct<time:timestamp,date:date>";

    private static final String TEST_FILE_DECIMAL = "test-data-decimal.orc";

    private static final String TEST_SCHEMA_DECIMAL = "struct<_col0:decimal(10,5)>";

    private static final String TEST_FILE_NESTEDLIST = "test-data-nestedlist.orc";

    private static final String TEST_SCHEMA_NESTEDLIST = "struct<mylist1:array<array<struct<mylong1:bigint>>>>";

    /**
     * Generated by {@link OrcTestFileGenerator#writeCompositeTypesWithNullsFile(String)}.
     */
    private static final String TEST_FILE_COMPOSITES_NULLS = "test-data-composites-with-nulls.orc";

    private static final String TEST_SCHEMA_COMPOSITES_NULLS = "struct<" + (((("int1:int," + "record1:struct<f1:int,f2:string>,") + "list1:array<array<array<struct<f1:string,f2:string>>>>,") + "list2:array<map<string,int>>") + ">");

    /**
     * Generated by {@link OrcTestFileGenerator#writeCompositeTypesWithRepeatingFile(String)}.
     */
    private static final String TEST_FILE_REPEATING = "test-data-repeating.orc";

    private static final String TEST_SCHEMA_REPEATING = "struct<" + (((((((((("int1:int," + "int2:int,") + "int3:int,") + "record1:struct<f1:int,f2:string>,") + "record2:struct<f1:int,f2:string>,") + "list1:array<int>,") + "list2:array<int>,") + "list3:array<int>,") + "map1:map<int,string>,") + "map2:map<int,string>") + ">");

    @Test(expected = FileNotFoundException.class)
    public void testInvalidPath() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat("/does/not/exist", OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        rowOrcInputFormat.openInputFormat();
        FileInputSplit[] inputSplits = rowOrcInputFormat.createInputSplits(1);
        rowOrcInputFormat.open(inputSplits[0]);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testInvalidProjection1() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        int[] projectionMask = new int[]{ 1, 2, 3, -1 };
        rowOrcInputFormat.selectFields(projectionMask);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testInvalidProjection2() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        int[] projectionMask = new int[]{ 1, 2, 3, 9 };
        rowOrcInputFormat.selectFields(projectionMask);
    }

    @Test
    public void testProjectionMaskNested() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        OrcRowInputFormat spy = Mockito.spy(rowOrcInputFormat);
        // mock options to check configuration of ORC reader
        Reader.Options options = new Reader.Options();
        Mockito.doReturn(options).when(spy).getOptions(ArgumentMatchers.any());
        spy.selectFields(9, 11, 2);
        spy.openInputFormat();
        FileInputSplit[] splits = spy.createInputSplits(1);
        spy.open(splits[0]);
        // top-level struct is false
        boolean[] expected = new boolean[]{ false// top level
        , false, false// flat fields 0, 1 are out
        , true// flat field 2 is in
        , false, false, false, false, false, false// flat fields 3, 4, 5, 6, 7, 8 are out
        , true, true, true, true, true// nested field 9 is in
        , false, false, false, false// nested field 10 is out
        , true, true, true, true, true };// nested field 11 is in

        Assert.assertArrayEquals(expected, options.getInclude());
    }

    @Test
    public void testSplitStripesGivenSplits() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        OrcRowInputFormat spy = Mockito.spy(rowOrcInputFormat);
        // mock options to check configuration of ORC reader
        Reader.Options options = Mockito.spy(new Reader.Options());
        Mockito.doReturn(options).when(spy).getOptions(ArgumentMatchers.any());
        FileInputSplit[] splits = spy.createInputSplits(3);
        spy.openInputFormat();
        spy.open(splits[0]);
        Mockito.verify(options).range(ArgumentMatchers.eq(3L), ArgumentMatchers.eq(137005L));
        spy.open(splits[1]);
        Mockito.verify(options).range(ArgumentMatchers.eq(137008L), ArgumentMatchers.eq(136182L));
        spy.open(splits[2]);
        Mockito.verify(options).range(ArgumentMatchers.eq(273190L), ArgumentMatchers.eq(123633L));
    }

    @Test
    public void testSplitStripesCustomSplits() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        OrcRowInputFormat spy = Mockito.spy(rowOrcInputFormat);
        // mock list of stripes
        List<StripeInformation> stripes = new ArrayList<>();
        StripeInformation stripe1 = Mockito.mock(StripeInformation.class);
        Mockito.when(stripe1.getOffset()).thenReturn(10L);
        Mockito.when(stripe1.getLength()).thenReturn(90L);
        StripeInformation stripe2 = Mockito.mock(StripeInformation.class);
        Mockito.when(stripe2.getOffset()).thenReturn(100L);
        Mockito.when(stripe2.getLength()).thenReturn(100L);
        StripeInformation stripe3 = Mockito.mock(StripeInformation.class);
        Mockito.when(stripe3.getOffset()).thenReturn(200L);
        Mockito.when(stripe3.getLength()).thenReturn(100L);
        StripeInformation stripe4 = Mockito.mock(StripeInformation.class);
        Mockito.when(stripe4.getOffset()).thenReturn(300L);
        Mockito.when(stripe4.getLength()).thenReturn(100L);
        StripeInformation stripe5 = Mockito.mock(StripeInformation.class);
        Mockito.when(stripe5.getOffset()).thenReturn(400L);
        Mockito.when(stripe5.getLength()).thenReturn(100L);
        stripes.add(stripe1);
        stripes.add(stripe2);
        stripes.add(stripe3);
        stripes.add(stripe4);
        stripes.add(stripe5);
        Mockito.doReturn(stripes).when(spy).getStripes(ArgumentMatchers.any());
        // mock options to check configuration of ORC reader
        Reader.Options options = Mockito.spy(new Reader.Options());
        Mockito.doReturn(options).when(spy).getOptions(ArgumentMatchers.any());
        spy.openInputFormat();
        // split ranging 2 stripes
        spy.open(new FileInputSplit(0, new Path(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT)), 0, 150, new String[]{  }));
        Mockito.verify(options).range(ArgumentMatchers.eq(10L), ArgumentMatchers.eq(190L));
        // split ranging 0 stripes
        spy.open(new FileInputSplit(1, new Path(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT)), 150, 10, new String[]{  }));
        Mockito.verify(options).range(ArgumentMatchers.eq(0L), ArgumentMatchers.eq(0L));
        // split ranging 1 stripe
        spy.open(new FileInputSplit(2, new Path(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT)), 160, 41, new String[]{  }));
        Mockito.verify(options).range(ArgumentMatchers.eq(200L), ArgumentMatchers.eq(100L));
        // split ranging 2 stripe
        spy.open(new FileInputSplit(3, new Path(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT)), 201, 299, new String[]{  }));
        Mockito.verify(options).range(ArgumentMatchers.eq(300L), ArgumentMatchers.eq(200L));
    }

    @Test
    public void testProducedType() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        Assert.assertTrue(((rowOrcInputFormat.getProducedType()) instanceof RowTypeInfo));
        RowTypeInfo producedType = ((RowTypeInfo) (rowOrcInputFormat.getProducedType()));
        Assert.assertArrayEquals(new TypeInformation[]{ // primitives
        Types.BOOLEAN, Types.BYTE, Types.SHORT, Types.INT, Types.LONG, Types.FLOAT, Types.DOUBLE, // binary
        PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO, // string
        Types.STRING, // struct
        Types.ROW_NAMED(new String[]{ "list" }, ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[]{ "int1", "string1" }, INT, STRING))), // list
        ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[]{ "int1", "string1" }, INT, STRING)), // map
        new org.apache.flink.api.java.typeutils.MapTypeInfo(Types.STRING, Types.ROW_NAMED(new String[]{ "int1", "string1" }, INT, STRING)) }, producedType.getFieldTypes());
        Assert.assertArrayEquals(new String[]{ "boolean1", "byte1", "short1", "int1", "long1", "float1", "double1", "bytes1", "string1", "middle", "list", "map" }, producedType.getFieldNames());
    }

    @Test
    public void testProducedTypeWithProjection() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        rowOrcInputFormat.selectFields(9, 3, 7, 10);
        Assert.assertTrue(((rowOrcInputFormat.getProducedType()) instanceof RowTypeInfo));
        RowTypeInfo producedType = ((RowTypeInfo) (rowOrcInputFormat.getProducedType()));
        Assert.assertArrayEquals(new TypeInformation[]{ // struct
        Types.ROW_NAMED(new String[]{ "list" }, ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[]{ "int1", "string1" }, INT, STRING))), // int
        Types.INT, // binary
        PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO, // list
        ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[]{ "int1", "string1" }, INT, STRING)) }, producedType.getFieldTypes());
        Assert.assertArrayEquals(new String[]{ "middle", "int1", "bytes1", "list" }, producedType.getFieldNames());
    }

    @Test
    public void testSerialization() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        rowOrcInputFormat.selectFields(0, 4, 1);
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("_col1", Type.STRING, "M"));
        byte[] bytes = InstantiationUtil.serializeObject(rowOrcInputFormat);
        OrcRowInputFormat copy = InstantiationUtil.deserializeObject(bytes, getClass().getClassLoader());
        FileInputSplit[] splits = copy.createInputSplits(1);
        copy.openInputFormat();
        copy.open(splits[0]);
        Assert.assertFalse(copy.reachedEnd());
        Row row = copy.nextRecord(null);
        Assert.assertNotNull(row);
        Assert.assertEquals(3, row.getArity());
        // check first row
        Assert.assertEquals(1, row.getField(0));
        Assert.assertEquals(500, row.getField(1));
        Assert.assertEquals("M", row.getField(2));
    }

    @Test
    public void testNumericBooleanStringPredicates() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        rowOrcInputFormat.selectFields(0, 1, 2, 3, 4, 5, 6, 8);
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("boolean1", Type.BOOLEAN, false));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.LessThan("byte1", Type.LONG, 1));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.LessThanEquals("short1", Type.LONG, 1024));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Between("int1", Type.LONG, (-1), 65536));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("long1", Type.LONG, 9223372036854775807L));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("float1", Type.FLOAT, 1.0));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("double1", Type.FLOAT, (-15.0)));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.IsNull("string1", Type.STRING));
        // boolean pred
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("string1", Type.STRING, "hello"));
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        rowOrcInputFormat.openInputFormat();
        // mock options to check configuration of ORC reader
        OrcRowInputFormat spy = Mockito.spy(rowOrcInputFormat);
        Reader.Options options = new Reader.Options();
        Mockito.doReturn(options).when(spy).getOptions(ArgumentMatchers.any());
        spy.openInputFormat();
        spy.open(splits[0]);
        // verify predicate configuration
        SearchArgument sarg = options.getSearchArgument();
        Assert.assertNotNull(sarg);
        Assert.assertEquals("(and leaf-0 leaf-1 leaf-2 leaf-3 leaf-4 leaf-5 leaf-6 leaf-7 leaf-8)", sarg.getExpression().toString());
        Assert.assertEquals(9, sarg.getLeaves().size());
        List<PredicateLeaf> leaves = sarg.getLeaves();
        Assert.assertEquals("(EQUALS boolean1 false)", leaves.get(0).toString());
        Assert.assertEquals("(LESS_THAN byte1 1)", leaves.get(1).toString());
        Assert.assertEquals("(LESS_THAN_EQUALS short1 1024)", leaves.get(2).toString());
        Assert.assertEquals("(BETWEEN int1 -1 65536)", leaves.get(3).toString());
        Assert.assertEquals("(EQUALS long1 9223372036854775807)", leaves.get(4).toString());
        Assert.assertEquals("(EQUALS float1 1.0)", leaves.get(5).toString());
        Assert.assertEquals("(EQUALS double1 -15.0)", leaves.get(6).toString());
        Assert.assertEquals("(IS_NULL string1)", leaves.get(7).toString());
        Assert.assertEquals("(EQUALS string1 hello)", leaves.get(8).toString());
    }

    @Test
    public void testTimePredicates() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_TIMETYPES), OrcRowInputFormatTest.TEST_SCHEMA_TIMETYPES, new Configuration());
        // OR
        rowOrcInputFormat.addPredicate(// timestamp pred
        // date pred
        new OrcRowInputFormat.Or(new OrcRowInputFormat.Equals("time", Type.TIMESTAMP, Timestamp.valueOf("1900-05-05 12:34:56.100")), new OrcRowInputFormat.Equals("date", Type.DATE, Date.valueOf("1900-12-25"))));
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        rowOrcInputFormat.openInputFormat();
        // mock options to check configuration of ORC reader
        OrcRowInputFormat spy = Mockito.spy(rowOrcInputFormat);
        Reader.Options options = new Reader.Options();
        Mockito.doReturn(options).when(spy).getOptions(ArgumentMatchers.any());
        spy.openInputFormat();
        spy.open(splits[0]);
        // verify predicate configuration
        SearchArgument sarg = options.getSearchArgument();
        Assert.assertNotNull(sarg);
        Assert.assertEquals("(or leaf-0 leaf-1)", sarg.getExpression().toString());
        Assert.assertEquals(2, sarg.getLeaves().size());
        List<PredicateLeaf> leaves = sarg.getLeaves();
        Assert.assertEquals("(EQUALS time 1900-05-05 12:34:56.1)", leaves.get(0).toString());
        Assert.assertEquals("(EQUALS date 1900-12-25)", leaves.get(1).toString());
    }

    @Test
    public void testDecimalPredicate() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_DECIMAL), OrcRowInputFormatTest.TEST_SCHEMA_DECIMAL, new Configuration());
        rowOrcInputFormat.addPredicate(// decimal pred
        new OrcRowInputFormat.Not(new OrcRowInputFormat.Equals("_col0", Type.DECIMAL, BigDecimal.valueOf((-1000.5)))));
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        rowOrcInputFormat.openInputFormat();
        // mock options to check configuration of ORC reader
        OrcRowInputFormat spy = Mockito.spy(rowOrcInputFormat);
        Reader.Options options = new Reader.Options();
        Mockito.doReturn(options).when(spy).getOptions(ArgumentMatchers.any());
        spy.openInputFormat();
        spy.open(splits[0]);
        // verify predicate configuration
        SearchArgument sarg = options.getSearchArgument();
        Assert.assertNotNull(sarg);
        Assert.assertEquals("(not leaf-0)", sarg.getExpression().toString());
        Assert.assertEquals(1, sarg.getLeaves().size());
        List<PredicateLeaf> leaves = sarg.getLeaves();
        Assert.assertEquals("(EQUALS _col0 -1000.5)", leaves.get(0).toString());
    }

    @Test(expected = IllegalArgumentException.class)
    public void testPredicateWithInvalidColumn() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("unknown", Type.LONG, 42));
    }

    @Test
    public void testReadNestedFile() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = rowOrcInputFormat.nextRecord(null);
        // validate first row
        Assert.assertNotNull(row);
        Assert.assertEquals(12, row.getArity());
        Assert.assertEquals(false, row.getField(0));
        Assert.assertEquals(((byte) (1)), row.getField(1));
        Assert.assertEquals(((short) (1024)), row.getField(2));
        Assert.assertEquals(65536, row.getField(3));
        Assert.assertEquals(9223372036854775807L, row.getField(4));
        Assert.assertEquals(1.0F, row.getField(5));
        Assert.assertEquals((-15.0), row.getField(6));
        Assert.assertArrayEquals(new byte[]{ 0, 1, 2, 3, 4 }, ((byte[]) (row.getField(7))));
        Assert.assertEquals("hi", row.getField(8));
        // check nested field
        Assert.assertTrue(((row.getField(9)) instanceof Row));
        Row nested1 = ((Row) (row.getField(9)));
        Assert.assertEquals(1, nested1.getArity());
        Assert.assertTrue(((nested1.getField(0)) instanceof Object[]));
        Object[] nestedList1 = ((Object[]) (nested1.getField(0)));
        Assert.assertEquals(2, nestedList1.length);
        Assert.assertEquals(Row.of(1, "bye"), nestedList1[0]);
        Assert.assertEquals(Row.of(2, "sigh"), nestedList1[1]);
        // check list
        Assert.assertTrue(((row.getField(10)) instanceof Object[]));
        Object[] list1 = ((Object[]) (row.getField(10)));
        Assert.assertEquals(2, list1.length);
        Assert.assertEquals(Row.of(3, "good"), list1[0]);
        Assert.assertEquals(Row.of(4, "bad"), list1[1]);
        // check map
        Assert.assertTrue(((row.getField(11)) instanceof HashMap));
        HashMap map1 = ((HashMap) (row.getField(11)));
        Assert.assertEquals(0, map1.size());
        // read second row
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        row = rowOrcInputFormat.nextRecord(null);
        // validate second row
        Assert.assertNotNull(row);
        Assert.assertEquals(12, row.getArity());
        Assert.assertEquals(true, row.getField(0));
        Assert.assertEquals(((byte) (100)), row.getField(1));
        Assert.assertEquals(((short) (2048)), row.getField(2));
        Assert.assertEquals(65536, row.getField(3));
        Assert.assertEquals(9223372036854775807L, row.getField(4));
        Assert.assertEquals(2.0F, row.getField(5));
        Assert.assertEquals((-5.0), row.getField(6));
        Assert.assertArrayEquals(new byte[]{  }, ((byte[]) (row.getField(7))));
        Assert.assertEquals("bye", row.getField(8));
        // check nested field
        Assert.assertTrue(((row.getField(9)) instanceof Row));
        Row nested2 = ((Row) (row.getField(9)));
        Assert.assertEquals(1, nested2.getArity());
        Assert.assertTrue(((nested2.getField(0)) instanceof Object[]));
        Object[] nestedList2 = ((Object[]) (nested2.getField(0)));
        Assert.assertEquals(2, nestedList2.length);
        Assert.assertEquals(Row.of(1, "bye"), nestedList2[0]);
        Assert.assertEquals(Row.of(2, "sigh"), nestedList2[1]);
        // check list
        Assert.assertTrue(((row.getField(10)) instanceof Object[]));
        Object[] list2 = ((Object[]) (row.getField(10)));
        Assert.assertEquals(3, list2.length);
        Assert.assertEquals(Row.of(100000000, "cat"), list2[0]);
        Assert.assertEquals(Row.of((-100000), "in"), list2[1]);
        Assert.assertEquals(Row.of(1234, "hat"), list2[2]);
        // check map
        Assert.assertTrue(((row.getField(11)) instanceof HashMap));
        HashMap map = ((HashMap) (row.getField(11)));
        Assert.assertEquals(2, map.size());
        Assert.assertEquals(Row.of(5, "chani"), map.get("chani"));
        Assert.assertEquals(Row.of(1, "mauddib"), map.get("mauddib"));
        Assert.assertTrue(rowOrcInputFormat.reachedEnd());
    }

    @Test
    public void testReadTimeTypeFile() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_TIMETYPES), OrcRowInputFormatTest.TEST_SCHEMA_TIMETYPES, new Configuration());
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = rowOrcInputFormat.nextRecord(null);
        // validate first row
        Assert.assertNotNull(row);
        Assert.assertEquals(2, row.getArity());
        Assert.assertEquals(Timestamp.valueOf("1900-05-05 12:34:56.1"), row.getField(0));
        Assert.assertEquals(Date.valueOf("1900-12-25"), row.getField(1));
        // check correct number of rows
        long cnt = 1;
        while (!(rowOrcInputFormat.reachedEnd())) {
            Assert.assertNotNull(rowOrcInputFormat.nextRecord(null));
            cnt++;
        } 
        Assert.assertEquals(70000, cnt);
    }

    @Test
    public void testReadDecimalTypeFile() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_DECIMAL), OrcRowInputFormatTest.TEST_SCHEMA_DECIMAL, new Configuration());
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = rowOrcInputFormat.nextRecord(null);
        // validate first row
        Assert.assertNotNull(row);
        Assert.assertEquals(1, row.getArity());
        Assert.assertEquals(BigDecimal.valueOf((-1000.5)), row.getField(0));
        // check correct number of rows
        long cnt = 1;
        while (!(rowOrcInputFormat.reachedEnd())) {
            Assert.assertNotNull(rowOrcInputFormat.nextRecord(null));
            cnt++;
        } 
        Assert.assertEquals(6000, cnt);
    }

    @Test
    public void testReadNestedListFile() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTEDLIST), OrcRowInputFormatTest.TEST_SCHEMA_NESTEDLIST, new Configuration());
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = null;
        long cnt = 0;
        // read all rows
        while (!(rowOrcInputFormat.reachedEnd())) {
            row = rowOrcInputFormat.nextRecord(row);
            Assert.assertEquals(1, row.getArity());
            // outer list
            Object[] list = ((Object[]) (row.getField(0)));
            Assert.assertEquals(1, list.length);
            // nested list of rows
            Row[] nestedRows = ((Row[]) (list[0]));
            Assert.assertEquals(1, nestedRows.length);
            Assert.assertEquals(1, getArity());
            // verify list value
            Assert.assertEquals(cnt, nestedRows[0].getField(0));
            cnt++;
        } 
        // number of rows in file
        Assert.assertEquals(100, cnt);
    }

    @Test
    public void testReadCompositesNullsFile() throws Exception {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_COMPOSITES_NULLS), OrcRowInputFormatTest.TEST_SCHEMA_COMPOSITES_NULLS, new Configuration());
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = null;
        long cnt = 0;
        int structNullCnt = 0;
        int nestedListNullCnt = 0;
        int mapListNullCnt = 0;
        // read all rows
        while (!(rowOrcInputFormat.reachedEnd())) {
            row = rowOrcInputFormat.nextRecord(row);
            Assert.assertEquals(4, row.getArity());
            Assert.assertTrue(((row.getField(0)) instanceof Integer));
            if ((row.getField(1)) == null) {
                structNullCnt++;
            } else {
                Object f = row.getField(1);
                Assert.assertTrue((f instanceof Row));
                Assert.assertEquals(2, getArity());
            }
            if ((row.getField(2)) == null) {
                nestedListNullCnt++;
            } else {
                Object f = row.getField(2);
                Assert.assertTrue((f instanceof Row[][][]));
                Assert.assertEquals(4, ((Row[][][]) (f)).length);
            }
            if ((row.getField(3)) == null) {
                mapListNullCnt++;
            } else {
                Object f = row.getField(3);
                Assert.assertTrue((f instanceof HashMap[]));
                Assert.assertEquals(3, ((HashMap[]) (f)).length);
            }
            cnt++;
        } 
        // number of rows in file
        Assert.assertEquals(2500, cnt);
        // check number of null fields
        Assert.assertEquals(1250, structNullCnt);
        Assert.assertEquals(835, nestedListNullCnt);
        Assert.assertEquals(835, mapListNullCnt);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void testReadRepeatingValuesFile() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_REPEATING), OrcRowInputFormatTest.TEST_SCHEMA_REPEATING, new Configuration());
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = null;
        long cnt = 0;
        Row firstRow1 = null;
        Integer[] firstList1 = null;
        HashMap firstMap1 = null;
        // read all rows
        while (!(rowOrcInputFormat.reachedEnd())) {
            cnt++;
            row = rowOrcInputFormat.nextRecord(row);
            Assert.assertEquals(10, row.getArity());
            // check first int field (always 42)
            Assert.assertNotNull(row.getField(0));
            Assert.assertTrue(((row.getField(0)) instanceof Integer));
            Assert.assertEquals(42, ((Integer) (row.getField(0))).intValue());
            // check second int field (always null)
            Assert.assertNull(row.getField(1));
            // check first int field (always 99)
            Assert.assertNotNull(row.getField(2));
            Assert.assertTrue(((row.getField(2)) instanceof Integer));
            Assert.assertEquals(99, ((Integer) (row.getField(2))).intValue());
            // check first row field (always (23, null))
            Assert.assertNotNull(row.getField(3));
            Assert.assertTrue(((row.getField(3)) instanceof Row));
            Row nestedRow = ((Row) (row.getField(3)));
            // check first field of nested row
            Assert.assertNotNull(nestedRow.getField(0));
            Assert.assertTrue(((nestedRow.getField(0)) instanceof Integer));
            Assert.assertEquals(23, ((Integer) (nestedRow.getField(0))).intValue());
            // check second field of nested row
            Assert.assertNull(nestedRow.getField(1));
            // validate reference
            if (firstRow1 == null) {
                firstRow1 = nestedRow;
            } else {
                // repeated rows must be different instances
                Assert.assertTrue((firstRow1 != nestedRow));
            }
            // check second row field (always null)
            Assert.assertNull(row.getField(4));
            // check first list field (always [1, 2, 3])
            Assert.assertNotNull(row.getField(5));
            Assert.assertTrue(((row.getField(5)) instanceof Integer[]));
            Integer[] list1 = ((Integer[]) (row.getField(5)));
            Assert.assertEquals(1, list1[0].intValue());
            Assert.assertEquals(2, list1[1].intValue());
            Assert.assertEquals(3, list1[2].intValue());
            // validate reference
            if (firstList1 == null) {
                firstList1 = list1;
            } else {
                // repeated list must be different instances
                Assert.assertTrue((firstList1 != list1));
            }
            // check second list field (always [7, 7, 7])
            Assert.assertNotNull(row.getField(6));
            Assert.assertTrue(((row.getField(6)) instanceof Integer[]));
            Integer[] list2 = ((Integer[]) (row.getField(6)));
            Assert.assertEquals(7, list2[0].intValue());
            Assert.assertEquals(7, list2[1].intValue());
            Assert.assertEquals(7, list2[2].intValue());
            // check third list field (always null)
            Assert.assertNull(row.getField(7));
            // check first map field (always {2->"Hello", 4->"Hello})
            Assert.assertNotNull(row.getField(8));
            Assert.assertTrue(((row.getField(8)) instanceof HashMap));
            HashMap<Integer, String> map = ((HashMap<Integer, String>) (row.getField(8)));
            Assert.assertEquals(2, map.size());
            Assert.assertEquals("Hello", map.get(2));
            Assert.assertEquals("Hello", map.get(4));
            // validate reference
            if (firstMap1 == null) {
                firstMap1 = map;
            } else {
                // repeated list must be different instances
                Assert.assertTrue((firstMap1 != map));
            }
            // check second map field (always null)
            Assert.assertNull(row.getField(9));
        } 
        rowOrcInputFormat.close();
        rowOrcInputFormat.closeInputFormat();
        Assert.assertEquals(256, cnt);
    }

    @Test
    public void testReadWithProjection() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_NESTED), OrcRowInputFormatTest.TEST_SCHEMA_NESTED, new Configuration());
        rowOrcInputFormat.selectFields(7, 0, 10, 8);
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        rowOrcInputFormat.open(splits[0]);
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = rowOrcInputFormat.nextRecord(null);
        // validate first row
        Assert.assertNotNull(row);
        Assert.assertEquals(4, row.getArity());
        // check binary
        Assert.assertArrayEquals(new byte[]{ 0, 1, 2, 3, 4 }, ((byte[]) (row.getField(0))));
        // check boolean
        Assert.assertEquals(false, row.getField(1));
        // check list
        Assert.assertTrue(((row.getField(2)) instanceof Object[]));
        Object[] list1 = ((Object[]) (row.getField(2)));
        Assert.assertEquals(2, list1.length);
        Assert.assertEquals(Row.of(3, "good"), list1[0]);
        Assert.assertEquals(Row.of(4, "bad"), list1[1]);
        // check string
        Assert.assertEquals("hi", row.getField(3));
        // check that there is a second row with four fields
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        row = rowOrcInputFormat.nextRecord(null);
        Assert.assertNotNull(row);
        Assert.assertEquals(4, row.getArity());
        Assert.assertTrue(rowOrcInputFormat.reachedEnd());
    }

    @Test
    public void testReadFileInSplits() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        rowOrcInputFormat.selectFields(0, 1);
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(4);
        Assert.assertEquals(4, splits.length);
        rowOrcInputFormat.openInputFormat();
        long cnt = 0;
        // read all splits
        for (FileInputSplit split : splits) {
            // open split
            rowOrcInputFormat.open(split);
            // read and count all rows
            while (!(rowOrcInputFormat.reachedEnd())) {
                Assert.assertNotNull(rowOrcInputFormat.nextRecord(null));
                cnt++;
            } 
        }
        // check that all rows have been read
        Assert.assertEquals(1920800, cnt);
    }

    @Test
    public void testReadFileWithFilter() throws IOException {
        rowOrcInputFormat = new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), OrcRowInputFormatTest.TEST_SCHEMA_FLAT, new Configuration());
        rowOrcInputFormat.selectFields(0, 1);
        // read head and tail of file
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Or(new OrcRowInputFormat.LessThan("_col0", Type.LONG, 10L), new OrcRowInputFormat.Not(new OrcRowInputFormat.LessThanEquals("_col0", Type.LONG, 1920000L))));
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.Equals("_col1", Type.STRING, "M"));
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        // open split
        rowOrcInputFormat.open(splits[0]);
        // read and count all rows
        long cnt = 0;
        while (!(rowOrcInputFormat.reachedEnd())) {
            Assert.assertNotNull(rowOrcInputFormat.nextRecord(null));
            cnt++;
        } 
        // check that only the first and last stripes of the file have been read.
        // Each stripe has 5000 rows, except the last which has 800 rows.
        Assert.assertEquals(5800, cnt);
    }

    @Test
    public void testReadFileWithEvolvedSchema() throws IOException {
        rowOrcInputFormat = // previous version of schema
        new OrcRowInputFormat(getPath(OrcRowInputFormatTest.TEST_FILE_FLAT), "struct<_col0:int,_col1:string,_col4:string,_col3:string>", new Configuration());
        rowOrcInputFormat.selectFields(3, 0, 2);
        rowOrcInputFormat.addPredicate(new OrcRowInputFormat.LessThan("_col0", Type.LONG, 10L));
        FileInputSplit[] splits = rowOrcInputFormat.createInputSplits(1);
        Assert.assertEquals(1, splits.length);
        rowOrcInputFormat.openInputFormat();
        // open split
        rowOrcInputFormat.open(splits[0]);
        // read and validate first row
        Assert.assertFalse(rowOrcInputFormat.reachedEnd());
        Row row = rowOrcInputFormat.nextRecord(null);
        Assert.assertNotNull(row);
        Assert.assertEquals(3, row.getArity());
        Assert.assertEquals("Primary", row.getField(0));
        Assert.assertEquals(1, row.getField(1));
        Assert.assertEquals("M", row.getField(2));
        // read and count remaining rows
        long cnt = 1;
        while (!(rowOrcInputFormat.reachedEnd())) {
            Assert.assertNotNull(rowOrcInputFormat.nextRecord(null));
            cnt++;
        } 
        // check that only the first and last stripes of the file have been read.
        // Each stripe has 5000 rows, except the last which has 800 rows.
        Assert.assertEquals(5000, cnt);
    }
}

